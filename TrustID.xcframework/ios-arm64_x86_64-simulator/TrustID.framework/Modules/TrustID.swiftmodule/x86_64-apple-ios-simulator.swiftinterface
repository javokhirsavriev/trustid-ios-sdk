// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target x86_64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name TrustID
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import AVFoundation
import Combine
import CommonCrypto
import Compression
import CoreFoundation
import CoreGraphics
import CoreNFC
import CoreText
import CryptoKit
import CryptoTokenKit
import DeveloperToolsSupport
import Dispatch
import Foundation
import MobileCoreServices
import QuartzCore
import Security
import Swift
import SwiftUI
import SystemConfiguration
@_exported import TrustID
import UIKit
import UniformTypeIdentifiers
import Vision
import _Concurrency
import _CoreNFC_UIKit
import _StringProcessing
import _SwiftConcurrencyShims
import zlib
extension Foundation.URLRequest {
  public var method: TrustID.HTTPMethod? {
    get
    set
  }
  public func validate() throws
}
public enum ReducedMotionOption {
  case specific(TrustID.ReducedMotionMode)
  case dynamic(any TrustID.ReducedMotionOptionProvider, dataID: Swift.AnyHashable)
}
extension TrustID.ReducedMotionOption {
  public static var standardMotion: TrustID.ReducedMotionOption {
    get
  }
  public static var reducedMotion: TrustID.ReducedMotionOption {
    get
  }
  public static var systemReducedMotionToggle: TrustID.ReducedMotionOption {
    get
  }
}
extension TrustID.ReducedMotionOption {
  public var currentReducedMotionMode: TrustID.ReducedMotionMode {
    get
  }
}
extension TrustID.ReducedMotionOption : Swift.Hashable {
  public static func == (lhs: TrustID.ReducedMotionOption, rhs: TrustID.ReducedMotionOption) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ReducedMotionMode : Swift.Hashable {
  case standardMotion
  case reducedMotion
  public static func == (a: TrustID.ReducedMotionMode, b: TrustID.ReducedMotionMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ReducedMotionOptionProvider {
  var currentReducedMotionMode: TrustID.ReducedMotionMode { get }
}
public struct SystemReducedMotionOptionProvider : TrustID.ReducedMotionOptionProvider {
  public init()
  public var currentReducedMotionMode: TrustID.ReducedMotionMode {
    get
  }
}
@available(*, deprecated, message: "Use DefaultAnimationCache instead, which is thread-safe and automatically responds to memory pressure.")
public typealias LRUAnimationCache = TrustID.DefaultAnimationCache
@objc @_Concurrency.MainActor @preconcurrency open class AnimatedControl : TrustID.LottieControlType {
  @_Concurrency.MainActor @preconcurrency public init(animation: TrustID.LottieAnimation?, configuration: TrustID.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency @objc dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func continueTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func cancelTracking(with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency open func animationDidSet()
  @_Concurrency.MainActor @preconcurrency final public let animationView: TrustID.LottieAnimationView
  @_Concurrency.MainActor @preconcurrency public var animation: TrustID.LottieAnimation? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func setLayer(named: Swift.String, forState: TrustID.LottieControlState)
  @_Concurrency.MainActor @preconcurrency public func setValueProvider(_ valueProvider: any TrustID.AnyValueProvider, keypath: TrustID.AnimationKeypath)
  @objc deinit
}
extension TrustID.Request {
  public static let didResumeNotification: Foundation.Notification.Name
  public static let didSuspendNotification: Foundation.Notification.Name
  public static let didCancelNotification: Foundation.Notification.Name
  public static let didFinishNotification: Foundation.Notification.Name
  public static let didResumeTaskNotification: Foundation.Notification.Name
  public static let didSuspendTaskNotification: Foundation.Notification.Name
  public static let didCancelTaskNotification: Foundation.Notification.Name
  public static let didCompleteTaskNotification: Foundation.Notification.Name
}
extension Foundation.Notification {
  public var request: TrustID.Request? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class AlamofireNotifications : TrustID.EventMonitor {
  final public func requestDidResume(_ request: TrustID.Request)
  final public func requestDidSuspend(_ request: TrustID.Request)
  final public func requestDidCancel(_ request: TrustID.Request)
  final public func requestDidFinish(_ request: TrustID.Request)
  final public func request(_ request: TrustID.Request, didResumeTask task: Foundation.URLSessionTask)
  final public func request(_ request: TrustID.Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func request(_ request: TrustID.Request, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: TrustID.Request, didCompleteTask task: Foundation.URLSessionTask, with error: TrustID.AFError?)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup14 : TrustID.DataGroup {
  public var securityInfos: [TrustID.SecurityInfo] {
    get
  }
  @objc deinit
}
public enum LogLevel : Swift.Int, Swift.CaseIterable {
  case verbose
  case debug
  case info
  case warning
  case error
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [TrustID.LogLevel]
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [TrustID.LogLevel] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Log {
  public static var logLevel: TrustID.LogLevel
  public static var storeLogs: Swift.Bool
  public static var logData: [Swift.String]
  public class func verbose(_ msg: @autoclosure () -> Swift.String)
  public class func debug(_ msg: @autoclosure () -> Swift.String)
  public class func info(_ msg: @autoclosure () -> Swift.String)
  public class func warning(_ msg: @autoclosure () -> Swift.String)
  public class func error(_ msg: @autoclosure () -> Swift.String)
  public class func clearStoredLogs()
  @objc deinit
}
public enum DotLottieError : Swift.Error {
  case noDataLoaded
  case assetNotFound(name: Swift.String, bundle: Foundation.Bundle?)
  case loadingFromAssetNotSupported
  @available(*, deprecated, message: "Unused")
  case invalidFileFormat
  @available(*, deprecated, message: "Unused")
  case invalidData
  @available(*, deprecated, message: "Unused")
  case animationNotAvailable
}
@objc public enum TrustIdLocale : Swift.Int {
  case Uzbek = 0
  case English
  case Russian
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
@_Concurrency.MainActor @preconcurrency public struct LottieButton {
  @_Concurrency.MainActor @preconcurrency public init(animation: TrustID.LottieAnimation?, action: @escaping () -> Swift.Void)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func configure(_ configure: @escaping (TrustID.AnimatedButton) -> Swift.Void) -> TrustID.LottieButton
  @_Concurrency.MainActor @preconcurrency public func configuration(_ configuration: TrustID.LottieConfiguration) -> TrustID.LottieButton
  @_Concurrency.MainActor @preconcurrency public func animate(fromProgress: TrustID.AnimationProgressTime, toProgress: TrustID.AnimationProgressTime, on event: TrustID.LottieControlEvent) -> TrustID.LottieButton
  @_Concurrency.MainActor @preconcurrency public func animate(fromMarker: Swift.String, toMarker: Swift.String, on event: TrustID.LottieControlEvent) -> TrustID.LottieButton
  @_Concurrency.MainActor @preconcurrency public func valueProvider<ValueProvider>(_ valueProvider: ValueProvider, for keypath: TrustID.AnimationKeypath) -> TrustID.LottieButton where ValueProvider : Swift.Equatable, ValueProvider : TrustID.AnyValueProvider
  @available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
  public typealias Body = @_opaqueReturnTypeOf("$s7TrustID12LottieButtonV4bodyQrvp", 0) __
}
extension QuartzCore.CALayer {
  @nonobjc public func logLayerTree(withIndent: Swift.Int = 0)
}
@available(iOS 13, macOS 10.15, *)
public struct DataGroupHash {
  public var id: Swift.String
  public var sodHash: Swift.String
  public var computedHash: Swift.String
  public var match: Swift.Bool
}
public protocol AuthenticationCredential {
  var requiresRefresh: Swift.Bool { get }
}
public protocol Authenticator : AnyObject {
  associatedtype Credential : TrustID.AuthenticationCredential
  func apply(_ credential: Self.Credential, to urlRequest: inout Foundation.URLRequest)
  func refresh(_ credential: Self.Credential, for session: TrustID.Session, completion: @escaping (Swift.Result<Self.Credential, any Swift.Error>) -> Swift.Void)
  func didRequest(_ urlRequest: Foundation.URLRequest, with response: Foundation.HTTPURLResponse, failDueToAuthenticationError error: any Swift.Error) -> Swift.Bool
  func isRequest(_ urlRequest: Foundation.URLRequest, authenticatedWith credential: Self.Credential) -> Swift.Bool
}
public enum AuthenticationError : Swift.Error {
  case missingCredential
  case excessiveRefresh
  public static func == (a: TrustID.AuthenticationError, b: TrustID.AuthenticationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class AuthenticationInterceptor<AuthenticatorType> : TrustID.RequestInterceptor where AuthenticatorType : TrustID.Authenticator {
  public typealias Credential = AuthenticatorType.Credential
  public struct RefreshWindow {
    public let interval: Foundation.TimeInterval
    public let maximumAttempts: Swift.Int
    public init(interval: Foundation.TimeInterval = 30.0, maximumAttempts: Swift.Int = 5)
  }
  public var credential: TrustID.AuthenticationInterceptor<AuthenticatorType>.Credential? {
    get
    set
  }
  public init(authenticator: AuthenticatorType, credential: TrustID.AuthenticationInterceptor<AuthenticatorType>.Credential? = nil, refreshWindow: TrustID.AuthenticationInterceptor<AuthenticatorType>.RefreshWindow? = RefreshWindow())
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: TrustID.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  public func retry(_ request: TrustID.Request, for session: TrustID.Session, dueTo error: any Swift.Error, completion: @escaping (TrustID.RetryResult) -> Swift.Void)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ImageAsset : TrustID.Asset {
  final public let name: Swift.String
  final public let directory: Swift.String
  final public let width: Swift.Double
  final public let height: Swift.Double
  override final public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
public protocol DotLottieCacheProvider : Swift.Sendable {
  func file(forKey: Swift.String) -> TrustID.DotLottieFile?
  func setFile(_ lottie: TrustID.DotLottieFile, forKey: Swift.String)
  func clearCache()
}
public class DotLottieCache : TrustID.DotLottieCacheProvider {
  public init()
  public static let sharedCache: TrustID.DotLottieCache
  public var cacheSize: Swift.Int {
    get
    set
  }
  public func clearCache()
  public func file(forKey key: Swift.String) -> TrustID.DotLottieFile?
  public func setFile(_ lottie: TrustID.DotLottieFile, forKey key: Swift.String)
  @objc deinit
}
extension TrustID.DotLottieCache : @unchecked Swift.Sendable {
}
@_hasMissingDesignatedInitializers @available(iOS 13, *)
public class TagReader {
  @objc deinit
}
public protocol EventMonitor {
  var queue: Dispatch.DispatchQueue { get }
  func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  func request(_ request: TrustID.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: TrustID.Request, didFailToCreateURLRequestWithError error: TrustID.AFError)
  func request(_ request: TrustID.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  func request(_ request: TrustID.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: TrustID.AFError)
  func request(_ request: TrustID.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: TrustID.Request, didCreateTask task: Foundation.URLSessionTask)
  func request(_ request: TrustID.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  func request(_ request: TrustID.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: TrustID.AFError)
  func request(_ request: TrustID.Request, didCompleteTask task: Foundation.URLSessionTask, with error: TrustID.AFError?)
  func requestIsRetrying(_ request: TrustID.Request)
  func requestDidFinish(_ request: TrustID.Request)
  func requestDidResume(_ request: TrustID.Request)
  func request(_ request: TrustID.Request, didResumeTask task: Foundation.URLSessionTask)
  func requestDidSuspend(_ request: TrustID.Request)
  func request(_ request: TrustID.Request, didSuspendTask task: Foundation.URLSessionTask)
  func requestDidCancel(_ request: TrustID.Request)
  func request(_ request: TrustID.Request, didCancelTask task: Foundation.URLSessionTask)
  func request(_ request: TrustID.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: TrustID.Request.ValidationResult)
  func request(_ request: TrustID.DataRequest, didParseResponse response: TrustID.DataResponse<Foundation.Data?, TrustID.AFError>)
  func request<Value>(_ request: TrustID.DataRequest, didParseResponse response: TrustID.DataResponse<Value, TrustID.AFError>)
  func request(_ request: TrustID.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: TrustID.Request.ValidationResult)
  func request<Value>(_ request: TrustID.DataStreamRequest, didParseStream result: Swift.Result<Value, TrustID.AFError>)
  func request(_ request: TrustID.UploadRequest, didCreateUploadable uploadable: TrustID.UploadRequest.Uploadable)
  func request(_ request: TrustID.UploadRequest, didFailToCreateUploadableWithError error: TrustID.AFError)
  func request(_ request: TrustID.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  func request(_ request: TrustID.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, TrustID.AFError>)
  func request(_ request: TrustID.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  func request(_ request: TrustID.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: TrustID.Request.ValidationResult)
  func request(_ request: TrustID.DownloadRequest, didParseResponse response: TrustID.DownloadResponse<Foundation.URL?, TrustID.AFError>)
  func request<Value>(_ request: TrustID.DownloadRequest, didParseResponse response: TrustID.DownloadResponse<Value, TrustID.AFError>)
}
extension TrustID.EventMonitor {
  public var queue: Dispatch.DispatchQueue {
    get
  }
  public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  public func request(_ request: TrustID.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: TrustID.Request, didFailToCreateURLRequestWithError error: TrustID.AFError)
  public func request(_ request: TrustID.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  public func request(_ request: TrustID.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: TrustID.AFError)
  public func request(_ request: TrustID.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: TrustID.Request, didCreateTask task: Foundation.URLSessionTask)
  public func request(_ request: TrustID.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  public func request(_ request: TrustID.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: TrustID.AFError)
  public func request(_ request: TrustID.Request, didCompleteTask task: Foundation.URLSessionTask, with error: TrustID.AFError?)
  public func requestIsRetrying(_ request: TrustID.Request)
  public func requestDidFinish(_ request: TrustID.Request)
  public func requestDidResume(_ request: TrustID.Request)
  public func request(_ request: TrustID.Request, didResumeTask task: Foundation.URLSessionTask)
  public func requestDidSuspend(_ request: TrustID.Request)
  public func request(_ request: TrustID.Request, didSuspendTask task: Foundation.URLSessionTask)
  public func requestDidCancel(_ request: TrustID.Request)
  public func request(_ request: TrustID.Request, didCancelTask task: Foundation.URLSessionTask)
  public func request(_ request: TrustID.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: TrustID.Request.ValidationResult)
  public func request(_ request: TrustID.DataRequest, didParseResponse response: TrustID.DataResponse<Foundation.Data?, TrustID.AFError>)
  public func request<Value>(_ request: TrustID.DataRequest, didParseResponse response: TrustID.DataResponse<Value, TrustID.AFError>)
  public func request(_ request: TrustID.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: TrustID.Request.ValidationResult)
  public func request<Value>(_ request: TrustID.DataStreamRequest, didParseStream result: Swift.Result<Value, TrustID.AFError>)
  public func request(_ request: TrustID.UploadRequest, didCreateUploadable uploadable: TrustID.UploadRequest.Uploadable)
  public func request(_ request: TrustID.UploadRequest, didFailToCreateUploadableWithError error: TrustID.AFError)
  public func request(_ request: TrustID.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  public func request(_ request: TrustID.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, TrustID.AFError>)
  public func request(_ request: TrustID.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  public func request(_ request: TrustID.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: TrustID.Request.ValidationResult)
  public func request(_ request: TrustID.DownloadRequest, didParseResponse response: TrustID.DownloadResponse<Foundation.URL?, TrustID.AFError>)
  public func request<Value>(_ request: TrustID.DownloadRequest, didParseResponse response: TrustID.DownloadResponse<Value, TrustID.AFError>)
}
@_hasMissingDesignatedInitializers final public class CompositeEventMonitor : TrustID.EventMonitor {
  final public let queue: Dispatch.DispatchQueue
  final public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  final public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  final public func request(_ request: TrustID.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: TrustID.Request, didFailToCreateURLRequestWithError error: TrustID.AFError)
  final public func request(_ request: TrustID.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  final public func request(_ request: TrustID.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: TrustID.AFError)
  final public func request(_ request: TrustID.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: TrustID.Request, didCreateTask task: Foundation.URLSessionTask)
  final public func request(_ request: TrustID.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  final public func request(_ request: TrustID.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: TrustID.AFError)
  final public func request(_ request: TrustID.Request, didCompleteTask task: Foundation.URLSessionTask, with error: TrustID.AFError?)
  final public func requestIsRetrying(_ request: TrustID.Request)
  final public func requestDidFinish(_ request: TrustID.Request)
  final public func requestDidResume(_ request: TrustID.Request)
  final public func request(_ request: TrustID.Request, didResumeTask task: Foundation.URLSessionTask)
  final public func requestDidSuspend(_ request: TrustID.Request)
  final public func request(_ request: TrustID.Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func requestDidCancel(_ request: TrustID.Request)
  final public func request(_ request: TrustID.Request, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: TrustID.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: TrustID.Request.ValidationResult)
  final public func request(_ request: TrustID.DataRequest, didParseResponse response: TrustID.DataResponse<Foundation.Data?, TrustID.AFError>)
  final public func request<Value>(_ request: TrustID.DataRequest, didParseResponse response: TrustID.DataResponse<Value, TrustID.AFError>)
  final public func request(_ request: TrustID.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: TrustID.Request.ValidationResult)
  final public func request<Value>(_ request: TrustID.DataStreamRequest, didParseStream result: Swift.Result<Value, TrustID.AFError>)
  final public func request(_ request: TrustID.UploadRequest, didCreateUploadable uploadable: TrustID.UploadRequest.Uploadable)
  final public func request(_ request: TrustID.UploadRequest, didFailToCreateUploadableWithError error: TrustID.AFError)
  final public func request(_ request: TrustID.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  final public func request(_ request: TrustID.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, TrustID.AFError>)
  final public func request(_ request: TrustID.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  final public func request(_ request: TrustID.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: TrustID.Request.ValidationResult)
  final public func request(_ request: TrustID.DownloadRequest, didParseResponse response: TrustID.DownloadResponse<Foundation.URL?, TrustID.AFError>)
  final public func request<Value>(_ request: TrustID.DownloadRequest, didParseResponse response: TrustID.DownloadResponse<Value, TrustID.AFError>)
  @objc deinit
}
open class ClosureEventMonitor : TrustID.EventMonitor {
  open var sessionDidBecomeInvalidWithError: ((Foundation.URLSession, (any Swift.Error)?) -> Swift.Void)?
  open var taskDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge) -> Swift.Void)?
  open var taskDidSendBodyData: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var taskNeedNewBodyStream: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var taskWillPerformHTTPRedirection: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest) -> Swift.Void)?
  open var taskDidFinishCollectingMetrics: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var taskDidComplete: ((Foundation.URLSession, Foundation.URLSessionTask, (any Swift.Error)?) -> Swift.Void)?
  open var taskIsWaitingForConnectivity: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var dataTaskDidReceiveResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.URLResponse) -> Swift.Void)?
  open var dataTaskDidReceiveData: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.Data) -> Swift.Void)?
  open var dataTaskWillCacheResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Swift.Void)?
  open var downloadTaskDidFinishDownloadingToURL: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Foundation.URL) -> Swift.Void)?
  open var downloadTaskDidWriteData: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var downloadTaskDidResumeAtOffset: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var requestDidCreateInitialURLRequest: ((TrustID.Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToCreateURLRequestWithError: ((TrustID.Request, TrustID.AFError) -> Swift.Void)?
  open var requestDidAdaptInitialRequestToAdaptedRequest: ((TrustID.Request, Foundation.URLRequest, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToAdaptURLRequestWithError: ((TrustID.Request, Foundation.URLRequest, TrustID.AFError) -> Swift.Void)?
  open var requestDidCreateURLRequest: ((TrustID.Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidCreateTask: ((TrustID.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidGatherMetrics: ((TrustID.Request, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var requestDidFailTaskEarlyWithError: ((TrustID.Request, Foundation.URLSessionTask, TrustID.AFError) -> Swift.Void)?
  open var requestDidCompleteTaskWithError: ((TrustID.Request, Foundation.URLSessionTask, TrustID.AFError?) -> Swift.Void)?
  open var requestIsRetrying: ((TrustID.Request) -> Swift.Void)?
  open var requestDidFinish: ((TrustID.Request) -> Swift.Void)?
  open var requestDidResume: ((TrustID.Request) -> Swift.Void)?
  open var requestDidResumeTask: ((TrustID.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidSuspend: ((TrustID.Request) -> Swift.Void)?
  open var requestDidSuspendTask: ((TrustID.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidCancel: ((TrustID.Request) -> Swift.Void)?
  open var requestDidCancelTask: ((TrustID.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidValidateRequestResponseDataWithResult: ((TrustID.DataRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?, TrustID.Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseResponse: ((TrustID.DataRequest, TrustID.DataResponse<Foundation.Data?, TrustID.AFError>) -> Swift.Void)?
  open var requestDidValidateRequestResponseWithResult: ((TrustID.DataStreamRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, TrustID.Request.ValidationResult) -> Swift.Void)?
  open var requestDidCreateUploadable: ((TrustID.UploadRequest, TrustID.UploadRequest.Uploadable) -> Swift.Void)?
  open var requestDidFailToCreateUploadableWithError: ((TrustID.UploadRequest, TrustID.AFError) -> Swift.Void)?
  open var requestDidProvideInputStream: ((TrustID.UploadRequest, Foundation.InputStream) -> Swift.Void)?
  open var requestDidFinishDownloadingUsingTaskWithResult: ((TrustID.DownloadRequest, Foundation.URLSessionTask, Swift.Result<Foundation.URL, TrustID.AFError>) -> Swift.Void)?
  open var requestDidCreateDestinationURL: ((TrustID.DownloadRequest, Foundation.URL) -> Swift.Void)?
  open var requestDidValidateRequestResponseFileURLWithResult: ((TrustID.DownloadRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.URL?, TrustID.Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseDownloadResponse: ((TrustID.DownloadRequest, TrustID.DownloadResponse<Foundation.URL?, TrustID.AFError>) -> Swift.Void)?
  final public let queue: Dispatch.DispatchQueue
  public init(queue: Dispatch.DispatchQueue = .main)
  open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  open func request(_ request: TrustID.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: TrustID.Request, didFailToCreateURLRequestWithError error: TrustID.AFError)
  open func request(_ request: TrustID.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  open func request(_ request: TrustID.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: TrustID.AFError)
  open func request(_ request: TrustID.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: TrustID.Request, didCreateTask task: Foundation.URLSessionTask)
  open func request(_ request: TrustID.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  open func request(_ request: TrustID.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: TrustID.AFError)
  open func request(_ request: TrustID.Request, didCompleteTask task: Foundation.URLSessionTask, with error: TrustID.AFError?)
  open func requestIsRetrying(_ request: TrustID.Request)
  open func requestDidFinish(_ request: TrustID.Request)
  open func requestDidResume(_ request: TrustID.Request)
  public func request(_ request: TrustID.Request, didResumeTask task: Foundation.URLSessionTask)
  open func requestDidSuspend(_ request: TrustID.Request)
  public func request(_ request: TrustID.Request, didSuspendTask task: Foundation.URLSessionTask)
  open func requestDidCancel(_ request: TrustID.Request)
  public func request(_ request: TrustID.Request, didCancelTask task: Foundation.URLSessionTask)
  open func request(_ request: TrustID.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: TrustID.Request.ValidationResult)
  open func request(_ request: TrustID.DataRequest, didParseResponse response: TrustID.DataResponse<Foundation.Data?, TrustID.AFError>)
  public func request(_ request: TrustID.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: TrustID.Request.ValidationResult)
  open func request(_ request: TrustID.UploadRequest, didCreateUploadable uploadable: TrustID.UploadRequest.Uploadable)
  open func request(_ request: TrustID.UploadRequest, didFailToCreateUploadableWithError error: TrustID.AFError)
  open func request(_ request: TrustID.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  open func request(_ request: TrustID.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, TrustID.AFError>)
  open func request(_ request: TrustID.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  open func request(_ request: TrustID.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: TrustID.Request.ValidationResult)
  open func request(_ request: TrustID.DownloadRequest, didParseResponse response: TrustID.DownloadResponse<Foundation.URL?, TrustID.AFError>)
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public enum NFCPassportReaderError : Swift.Error {
  case ResponseError(Swift.String, Swift.UInt8, Swift.UInt8)
  case InvalidResponse
  case UnexpectedError
  case NFCNotSupported
  case NoConnectedTag
  case D087Malformed
  case InvalidResponseChecksum
  case MissingMandatoryFields
  case CannotDecodeASN1Length
  case InvalidASN1Value
  case UnableToProtectAPDU
  case UnableToUnprotectAPDU
  case UnsupportedDataGroup
  case DataGroupNotRead
  case UnknownTag
  case UnknownImageFormat
  case NotImplemented
  case TagNotValid
  case ConnectionError
  case UserCanceled
  case InvalidMRZKey
  case MoreThanOneTagFound
  case InvalidHashAlgorithmSpecified
  case InvalidDataPassed(Swift.String)
  case NotYetSupported(Swift.String)
}
@available(iOS 13, macOS 10.15, *)
extension TrustID.NFCPassportReaderError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public enum OpenSSLError : Swift.Error {
  case UnableToGetX509CertificateFromPKCS7(Swift.String)
  case UnableToVerifyX509CertificateForSOD(Swift.String)
  case VerifyAndReturnSODEncapsulatedData(Swift.String)
  case UnableToReadECPublicKey(Swift.String)
  case UnableToExtractSignedDataFromPKCS7(Swift.String)
  case VerifySignedAttributes(Swift.String)
  case UnableToParseASN1(Swift.String)
  case UnableToDecryptRSASignature(Swift.String)
}
@available(iOS 13, macOS 10.15, *)
extension TrustID.OpenSSLError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum PassiveAuthenticationError : Swift.Error {
  case UnableToParseSODHashes(Swift.String)
  case InvalidDataGroupHash(Swift.String)
  case SODMissing(Swift.String)
}
extension TrustID.PassiveAuthenticationError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class NotImplementedDG : TrustID.DataGroup {
  @objc deinit
}
extension UIKit.UIColor {
  public var lottieColorValue: TrustID.LottieColor {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class SecurityInfo {
  public func getObjectIdentifier() -> Swift.String
  public func getProtocolOIDString() -> Swift.String
  @objc deinit
}
public protocol Interpolatable : TrustID.AnyInterpolatable {
  func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
}
public protocol SpatialInterpolatable : TrustID.AnyInterpolatable {
  func interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
public protocol AnyInterpolatable {
  func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
extension TrustID.Interpolatable {
  public func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent _: CoreFoundation.CGPoint?, spatialInTangent _: CoreFoundation.CGPoint?) -> Self
}
extension TrustID.SpatialInterpolatable {
  public func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
  public func _interpolate(to: Self, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> Self
}
extension Swift.Double : TrustID.Interpolatable {
}
extension CoreFoundation.CGFloat : TrustID.Interpolatable {
}
extension Swift.Float : TrustID.Interpolatable {
}
extension TrustID.Interpolatable where Self : Swift.BinaryFloatingPoint {
  public func interpolate(to: Self, amount: CoreFoundation.CGFloat) -> Self
}
extension CoreFoundation.CGRect : TrustID.Interpolatable {
  public func interpolate(to: CoreFoundation.CGRect, amount: CoreFoundation.CGFloat) -> CoreFoundation.CGRect
}
extension CoreFoundation.CGSize : TrustID.Interpolatable {
  public func interpolate(to: CoreFoundation.CGSize, amount: CoreFoundation.CGFloat) -> CoreFoundation.CGSize
}
extension CoreFoundation.CGPoint : TrustID.SpatialInterpolatable {
  public func interpolate(to: CoreFoundation.CGPoint, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> CoreFoundation.CGPoint
}
extension TrustID.LottieColor : TrustID.Interpolatable {
  public func interpolate(to: TrustID.LottieColor, amount: CoreFoundation.CGFloat) -> TrustID.LottieColor
}
extension TrustID.LottieVector1D : TrustID.Interpolatable {
  public func interpolate(to: TrustID.LottieVector1D, amount: CoreFoundation.CGFloat) -> TrustID.LottieVector1D
}
extension TrustID.LottieVector2D : TrustID.SpatialInterpolatable {
  public func interpolate(to: TrustID.LottieVector2D, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> TrustID.LottieVector2D
}
extension TrustID.LottieVector3D : TrustID.SpatialInterpolatable {
  public func interpolate(to: TrustID.LottieVector3D, amount: CoreFoundation.CGFloat, spatialOutTangent: CoreFoundation.CGPoint?, spatialInTangent: CoreFoundation.CGPoint?) -> TrustID.LottieVector3D
}
extension Swift.Array : TrustID.Interpolatable, TrustID.AnyInterpolatable where Element : TrustID.Interpolatable {
  public func interpolate(to: [Element], amount: CoreFoundation.CGFloat) -> [Element]
}
#if compiler(>=5.3) && $NoncopyableGenerics
extension Swift.Optional : TrustID.Interpolatable, TrustID.AnyInterpolatable where Wrapped : TrustID.Interpolatable {
  public func interpolate(to: Wrapped?, amount: CoreFoundation.CGFloat) -> Wrapped?
}
#else
extension Swift.Optional : TrustID.Interpolatable, TrustID.AnyInterpolatable where Wrapped : TrustID.Interpolatable {
  public func interpolate(to: Wrapped?, amount: CoreFoundation.CGFloat) -> Wrapped?
}
#endif
public enum CoordinateSpace : Swift.Int, Swift.Codable, Swift.Sendable {
  case type2d
  case type3d
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
final public class LottieAnimation : Swift.Codable, Swift.Sendable {
  required public init(from decoder: any Swift.Decoder) throws
  public init(dictionary: [Swift.String : Any]) throws
  final public let startFrame: TrustID.AnimationFrameTime
  final public let endFrame: TrustID.AnimationFrameTime
  final public let framerate: Swift.Double
  final public var markerNames: [Swift.String] {
    get
  }
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class COM : TrustID.DataGroup {
  public var version: Swift.String {
    get
  }
  public var unicodeVersion: Swift.String {
    get
  }
  public var dataGroupsPresent: [Swift.String] {
    get
  }
  @objc deinit
}
public enum PassportAuthenticationStatus {
  case notDone
  case success
  case failed
  public static func == (a: TrustID.PassportAuthenticationStatus, b: TrustID.PassportAuthenticationStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public class NFCPassportModel {
  public var documentType: Swift.String {
    get
  }
  public var documentSubType: Swift.String {
    get
  }
  public var documentNumber: Swift.String {
    get
  }
  public var issuingAuthority: Swift.String {
    get
  }
  public var documentExpiryDate: Swift.String {
    get
  }
  public var dateOfBirth: Swift.String {
    get
  }
  public var gender: Swift.String {
    get
  }
  public var nationality: Swift.String {
    get
  }
  public var lastName: Swift.String {
    get
  }
  public var firstName: Swift.String {
    get
  }
  public var passportMRZ: Swift.String {
    get
  }
  public var placeOfBirth: Swift.String? {
    get
  }
  public var residenceAddress: Swift.String? {
    get
  }
  public var phoneNumber: Swift.String? {
    get
  }
  public var personalNumber: Swift.String? {
    get
  }
  public var documentSigningCertificate: TrustID.X509Wrapper? {
    get
  }
  public var countrySigningCertificate: TrustID.X509Wrapper? {
    get
  }
  public var LDSVersion: Swift.String {
    get
  }
  public var dataGroupsPresent: [Swift.String] {
    get
  }
  public var dataGroupsAvailable: [TrustID.DataGroupId] {
    get
  }
  public var dataGroupsRead: [TrustID.DataGroupId : TrustID.DataGroup] {
    get
  }
  public var dataGroupHashes: [TrustID.DataGroupId : TrustID.DataGroupHash] {
    get
  }
  public var cardAccess: TrustID.CardAccess? {
    get
  }
  public var BACStatus: TrustID.PassportAuthenticationStatus {
    get
  }
  public var PACEStatus: TrustID.PassportAuthenticationStatus {
    get
  }
  public var chipAuthenticationStatus: TrustID.PassportAuthenticationStatus {
    get
  }
  public var passportCorrectlySigned: Swift.Bool {
    get
  }
  public var documentSigningCertificateVerified: Swift.Bool {
    get
  }
  public var passportDataNotTampered: Swift.Bool {
    get
  }
  public var activeAuthenticationPassed: Swift.Bool {
    get
  }
  public var activeAuthenticationChallenge: [Swift.UInt8] {
    get
  }
  public var activeAuthenticationSignature: [Swift.UInt8] {
    get
  }
  public var verificationErrors: [any Swift.Error] {
    get
  }
  public var isPACESupported: Swift.Bool {
    get
  }
  public var isChipAuthenticationSupported: Swift.Bool {
    get
  }
  public var passportImage: UIKit.UIImage? {
    get
  }
  public var signatureImage: UIKit.UIImage? {
    get
  }
  public var activeAuthenticationSupported: Swift.Bool {
    get
  }
  public init()
  public init(from dump: [Swift.String : Swift.String])
  public func addDataGroup(_ id: TrustID.DataGroupId, dataGroup: TrustID.DataGroup)
  public func getDataGroup(_ id: TrustID.DataGroupId) -> TrustID.DataGroup?
  public func dumpPassportData(selectedDataGroups: [TrustID.DataGroupId], includeActiveAuthenticationData: Swift.Bool = false) -> [Swift.String : Swift.String]
  public func getHashesForDatagroups(hashAlgorythm: Swift.String) -> [TrustID.DataGroupId : [Swift.UInt8]]
  public func verifyPassport(masterListURL: Foundation.URL?, useCMSVerification: Swift.Bool = false)
  public func verifyActiveAuthentication(challenge: [Swift.UInt8], signature: [Swift.UInt8])
  @objc deinit
}
@available(iOS 13, *)
public class BACHandler {
  public var ksenc: [Swift.UInt8]
  public var ksmac: [Swift.UInt8]
  public var kifd: [Swift.UInt8]
  public init()
  public init(tagReader: TrustID.TagReader)
  public func performBACAndGetSessionKeys(mrzKey: Swift.String, completed: @escaping (_ error: TrustID.NFCPassportReaderError?) -> ())
  public func sessionKeys(data: [Swift.UInt8]) throws -> ([Swift.UInt8], [Swift.UInt8], [Swift.UInt8])
  @objc deinit
}
public enum LottieAnimationCache {
  public static var shared: (any TrustID.AnimationCacheProvider)?
}
public struct HTTPMethod : Swift.RawRepresentable, Swift.Equatable, Swift.Hashable {
  public static let connect: TrustID.HTTPMethod
  public static let delete: TrustID.HTTPMethod
  public static let get: TrustID.HTTPMethod
  public static let head: TrustID.HTTPMethod
  public static let options: TrustID.HTTPMethod
  public static let patch: TrustID.HTTPMethod
  public static let post: TrustID.HTTPMethod
  public static let put: TrustID.HTTPMethod
  public static let query: TrustID.HTTPMethod
  public static let trace: TrustID.HTTPMethod
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
@_inheritsConvenienceInitializers @objc public class TrustIdException : ObjectiveC.NSObject {
  @objc public var message: Swift.String?
  @objc public var code: Swift.Int
  @objc override dynamic public init()
  @objc deinit
}
final public class FloatValueProvider {
  public init(block: @escaping TrustID.FloatValueProvider.CGFloatValueBlock)
  public init(_ float: CoreFoundation.CGFloat)
  public typealias CGFloatValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var float: CoreFoundation.CGFloat {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: TrustID.ValueProviderStorage<TrustID.LottieVector1D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension TrustID.FloatValueProvider : Swift.Equatable {
  public static func == (lhs: TrustID.FloatValueProvider, rhs: TrustID.FloatValueProvider) -> Swift.Bool
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class ActiveAuthenticationInfo : TrustID.SecurityInfo {
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getSignatureAlgorithmOIDString() -> Swift.String?
  @objc deinit
}
extension TrustID.LottieColor : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@_inheritsConvenienceInitializers @objc public class TrustIdClient : ObjectiveC.NSObject {
  @objc public class func showScanner(withConfig config: TrustID.TrustIdConfig, withDelegate delegate: any TrustID.TrustIdClientDelegate)
  @objc override dynamic public init()
  @objc deinit
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DeflateRequestCompressor : TrustID.RequestInterceptor {
  public enum DuplicateHeaderBehavior {
    case error
    case replace
    case skip
    public static func == (a: TrustID.DeflateRequestCompressor.DuplicateHeaderBehavior, b: TrustID.DeflateRequestCompressor.DuplicateHeaderBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct DuplicateHeaderError : Swift.Error {
  }
  public let duplicateHeaderBehavior: TrustID.DeflateRequestCompressor.DuplicateHeaderBehavior
  public let shouldCompressBodyData: (_ bodyData: Foundation.Data) -> Swift.Bool
  public init(duplicateHeaderBehavior: TrustID.DeflateRequestCompressor.DuplicateHeaderBehavior = .error, shouldCompressBodyData: @escaping (_ bodyData: Foundation.Data) -> Swift.Bool = { _ in true })
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: TrustID.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension TrustID.RequestInterceptor where Self == TrustID.DeflateRequestCompressor {
  public static var deflateCompressor: TrustID.DeflateRequestCompressor {
    get
  }
  public static func deflateCompressor(duplicateHeaderBehavior: TrustID.DeflateRequestCompressor.DuplicateHeaderBehavior = .error, shouldCompressBodyData: @escaping (_ bodyData: Foundation.Data) -> Swift.Bool = { _ in true }) -> TrustID.DeflateRequestCompressor
}
extension TrustID.Request {
  public typealias ValidationResult = Swift.Result<Swift.Void, any Swift.Error>
}
extension TrustID.DataRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?) -> TrustID.DataRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension TrustID.DataStreamRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse) -> TrustID.DataStreamRequest.ValidationResult
  @discardableResult
  final public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  final public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  final public func validate() -> Self
}
extension TrustID.DownloadRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse, _ fileURL: Foundation.URL?) -> TrustID.DownloadRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
@available(iOS 13, macOS 10.15, *)
public enum CertificateType {
  case documentSigningCertificate
  case issuerSigningCertificate
  public static func == (a: TrustID.CertificateType, b: TrustID.CertificateType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public enum CertificateItem : Swift.String {
  case fingerprint
  case issuerName
  case subjectName
  case serialNumber
  case signatureAlgorithm
  case publicKeyAlgorithm
  case notBefore
  case notAfter
  public init?(rawValue: Swift.String)
  @available(iOS 13, macOS 10.15, *)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@available(iOS 13, macOS 10.15, *)
public class X509Wrapper {
  final public let cert: Swift.OpaquePointer
  public init?(with cert: Swift.OpaquePointer?)
  public func getItemsAsDict() -> [TrustID.CertificateItem : Swift.String]
  public func certToPEM() -> Swift.String
  public func getFingerprint() -> Swift.String?
  public func getNotBeforeDate() -> Swift.String?
  public func getNotAfterDate() -> Swift.String?
  public func getSerialNumber() -> Swift.String?
  public func getSignatureAlgorithm() -> Swift.String?
  public func getPublicKeyAlgorithm() -> Swift.String?
  public func getIssuerName() -> Swift.String?
  public func getSubjectName() -> Swift.String?
  @objc deinit
}
public protocol URLConvertible {
  func asURL() throws -> Foundation.URL
}
extension Swift.String : TrustID.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URL : TrustID.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URLComponents : TrustID.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
public protocol URLRequestConvertible {
  func asURLRequest() throws -> Foundation.URLRequest
}
extension TrustID.URLRequestConvertible {
  public var urlRequest: Foundation.URLRequest? {
    get
  }
}
extension Foundation.URLRequest : TrustID.URLRequestConvertible {
  public func asURLRequest() throws -> Foundation.URLRequest
}
extension Foundation.URLRequest {
  public init(url: any TrustID.URLConvertible, method: TrustID.HTTPMethod, headers: TrustID.HTTPHeaders? = nil) throws
}
public class DefaultAnimationCache : TrustID.AnimationCacheProvider {
  public init()
  public static let sharedCache: TrustID.DefaultAnimationCache
  public var cacheSize: Swift.Int {
    get
    set
  }
  public func clearCache()
  public func animation(forKey key: Swift.String) -> TrustID.LottieAnimation?
  public func setAnimation(_ animation: TrustID.LottieAnimation, forKey key: Swift.String)
  @objc deinit
}
extension TrustID.DefaultAnimationCache : @unchecked Swift.Sendable {
}
final public class Keyframe<T> {
  public init(_ value: T, spatialInTangent: TrustID.LottieVector3D? = nil, spatialOutTangent: TrustID.LottieVector3D? = nil)
  public init(value: T, time: TrustID.AnimationFrameTime, isHold: Swift.Bool = false, inTangent: TrustID.LottieVector2D? = nil, outTangent: TrustID.LottieVector2D? = nil, spatialInTangent: TrustID.LottieVector3D? = nil, spatialOutTangent: TrustID.LottieVector3D? = nil)
  final public let value: T
  final public let time: TrustID.AnimationFrameTime
  final public let isHold: Swift.Bool
  final public let inTangent: TrustID.LottieVector2D?
  final public let outTangent: TrustID.LottieVector2D?
  final public let spatialInTangent: TrustID.LottieVector3D?
  final public let spatialOutTangent: TrustID.LottieVector3D?
  @objc deinit
}
extension TrustID.Keyframe : Swift.Equatable where T : Swift.Equatable {
  public static func == (lhs: TrustID.Keyframe<T>, rhs: TrustID.Keyframe<T>) -> Swift.Bool
}
extension TrustID.Keyframe : Swift.Hashable where T : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
extension TrustID.Keyframe : Swift.Sendable where T : Swift.Sendable {
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class ChipAuthenticationPublicKeyInfo : TrustID.SecurityInfo {
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getKeyId() -> Swift.Int
  @objc deinit
}
final public class PointValueProvider {
  public init(block: @escaping TrustID.PointValueProvider.PointValueBlock)
  public init(_ point: CoreFoundation.CGPoint)
  public typealias PointValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
  final public var point: CoreFoundation.CGPoint {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: TrustID.ValueProviderStorage<TrustID.LottieVector3D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension TrustID.PointValueProvider : Swift.Equatable {
  public static func == (lhs: TrustID.PointValueProvider, rhs: TrustID.PointValueProvider) -> Swift.Bool
}
@_inheritsConvenienceInitializers @objc public class TrustIdConfig : ObjectiveC.NSObject {
  @objc public var apiKey: Swift.String
  @objc public var faceImage: UIKit.UIImage?
  @objc public var environment: TrustID.TrustIdEnvironment
  @objc public var documentType: TrustID.TrustIdDocumentType
  @objc public var documentNumber: Swift.String
  @objc public var dateOfBirth: Swift.String
  @objc public var dateOfExpiry: Swift.String
  @objc public var locale: TrustID.TrustIdLocale
  @objc public var presentationStyle: TrustID.TrustIdPresentationStyle
  @objc public var appearance: TrustID.TrustIdAppearance?
  @objc public var withApi: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency final public class AnimationSubview : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension Foundation.URLSessionConfiguration : TrustID.AlamofireExtended {
  @available(iOS 7.0, *)
  public typealias ExtendedType = Foundation.URLSessionConfiguration
}
extension TrustID.AlamofireExtension where ExtendedType : Foundation.URLSessionConfiguration {
  public static var `default`: Foundation.URLSessionConfiguration {
    get
  }
  public static var ephemeral: Foundation.URLSessionConfiguration {
    get
  }
}
@_inheritsConvenienceInitializers @objc public class TrustIdResult : ObjectiveC.NSObject {
  @objc public var documentData: TrustID.TrustIdDocumentData
  @objc public var documentFaceImage: UIKit.UIImage?
  @objc public var documentFrontImage: UIKit.UIImage?
  @objc public var documentBackImage: UIKit.UIImage?
  @objc public var transactionId: Swift.String
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class TrustIdDocumentData : ObjectiveC.NSObject {
  @objc public var pinfl: Swift.String
  @objc public var document: Swift.String
  @objc public var documentType: TrustID.TrustIdDocumentType
  @objc public var lastName: Swift.String
  @objc public var firstName: Swift.String
  @objc public var middleName: Swift.String
  @objc public var issuedBy: Swift.String
  @objc public var issuedDate: Swift.String
  @objc public var expiryDate: Swift.String
  @objc public var birthPlace: Swift.String
  @objc public var birthDate: Swift.String
  @objc public var mrz: Swift.String
  @objc public var mrzKey: Swift.String
  @objc override dynamic public init()
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public enum DocTypeEnum : Swift.String {
  case TD1
  case TD2
  case OTHER
  public init?(rawValue: Swift.String)
  @available(iOS 13, macOS 10.15, *)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup1 : TrustID.DataGroup {
  public var elements: [Swift.String : Swift.String] {
    get
  }
  @objc deinit
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = TrustID.DataResponse<Value, TrustID.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: TrustID.DataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : TrustID.ResponseSerializer
  public init<Serializer>(_ request: TrustID.DataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : TrustID.DataResponseSerializerProtocol
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, TrustID.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, TrustID.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == TrustID.DataResponse<Value, TrustID.AFError>
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension TrustID.DataResponsePublisher where Value == Foundation.Data? {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: TrustID.DataRequest, queue: Dispatch.DispatchQueue)
}
extension TrustID.DataRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> TrustID.DataResponsePublisher<T> where Serializer : TrustID.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: any TrustID.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> TrustID.DataResponsePublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: any TrustID.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> TrustID.DataResponsePublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Renamed publishDecodable(type:queue:preprocessor:decoder:emptyResponseCodes:emptyRequestMethods).")
  @_disfavoredOverload public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: any TrustID.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any TrustID.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<TrustID.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> TrustID.DataResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: any TrustID.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any TrustID.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> TrustID.DataResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(queue: Dispatch.DispatchQueue = .main) -> TrustID.DataResponsePublisher<Foundation.Data?>
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataStreamPublisher<Value> : Combine.Publisher {
  public typealias Output = TrustID.DataStreamRequest.Stream<Value, TrustID.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: TrustID.DataStreamRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : TrustID.DataStreamSerializer
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, TrustID.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, TrustID.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == TrustID.DataStreamRequest.Stream<Value, TrustID.AFError>
}
extension TrustID.DataStreamRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> TrustID.DataStreamPublisher<Serializer.SerializedObject> where Serializer : TrustID.DataStreamSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishData(queue: Dispatch.DispatchQueue = .main) -> TrustID.DataStreamPublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishString(queue: Dispatch.DispatchQueue = .main) -> TrustID.DataStreamPublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, decoder: any TrustID.DataDecoder = JSONDecoder(), preprocessor: any TrustID.DataPreprocessor = PassthroughPreprocessor()) -> TrustID.DataStreamPublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DownloadResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = TrustID.DownloadResponse<Value, TrustID.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: TrustID.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : TrustID.ResponseSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init<Serializer>(_ request: TrustID.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : TrustID.DownloadResponseSerializerProtocol
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, TrustID.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, TrustID.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == TrustID.DownloadResponse<Value, TrustID.AFError>
}
extension TrustID.DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> TrustID.DownloadResponsePublisher<T> where Serializer : TrustID.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> TrustID.DownloadResponsePublisher<T> where Serializer : TrustID.DownloadResponseSerializerProtocol, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishURL(queue: Dispatch.DispatchQueue = .main) -> TrustID.DownloadResponsePublisher<Foundation.URL>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: any TrustID.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> TrustID.DownloadResponsePublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: any TrustID.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> TrustID.DownloadResponsePublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Renamed publishDecodable(type:queue:preprocessor:decoder:emptyResponseCodes:emptyRequestMethods).")
  @_disfavoredOverload public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: any TrustID.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any TrustID.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<TrustID.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> TrustID.DownloadResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: any TrustID.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any TrustID.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> TrustID.DownloadResponsePublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension TrustID.DownloadResponsePublisher where Value == Foundation.URL? {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: TrustID.DownloadRequest, queue: Dispatch.DispatchQueue)
}
extension TrustID.DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(on queue: Dispatch.DispatchQueue = .main) -> TrustID.DownloadResponsePublisher<Foundation.URL?>
}
@available(iOS 13, macOS 10.15, *)
public func AESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func AESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func AESECBEncrypt(key: [Swift.UInt8], message: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func tripleDESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func tripleDESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func DESEncrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8], options: Swift.UInt32 = 0) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func DESDecrypt(key: [Swift.UInt8], message: [Swift.UInt8], iv: [Swift.UInt8], options: Swift.UInt32 = 0) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public enum NFCViewDisplayMessage {
  case requestPresentPassport
  case authenticatingWithPassport(Swift.Int)
  case readingDataGroupProgress(TrustID.DataGroupId, Swift.Int)
  case error(TrustID.NFCPassportReaderError)
  case successfulRead
}
@available(iOS 13, macOS 10.15, *)
extension TrustID.NFCViewDisplayMessage {
  public var description: Swift.String {
    get
  }
}
public protocol RedirectHandler {
  func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct Redirector {
  public enum Behavior {
    case follow
    case doNotFollow
    case modify((Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?)
  }
  public static let follow: TrustID.Redirector
  public static let doNotFollow: TrustID.Redirector
  public let behavior: TrustID.Redirector.Behavior
  public init(behavior: TrustID.Redirector.Behavior)
}
extension TrustID.Redirector : TrustID.RedirectHandler {
  public func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
extension TrustID.RedirectHandler where Self == TrustID.Redirector {
  public static var follow: TrustID.Redirector {
    get
  }
  public static var doNotFollow: TrustID.Redirector {
    get
  }
  public static func modify(using closure: @escaping (Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?) -> TrustID.Redirector
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class CardAccess {
  public var securityInfos: [TrustID.SecurityInfo] {
    get
  }
  @objc deinit
}
public typealias Parameters = [Swift.String : Any]
public protocol ParameterEncoding {
  func encode(_ urlRequest: any TrustID.URLRequestConvertible, with parameters: TrustID.Parameters?) throws -> Foundation.URLRequest
}
public struct URLEncoding : TrustID.ParameterEncoding {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: TrustID.URLEncoding.Destination, b: TrustID.URLEncoding.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    case custom((_ key: Swift.String, _ index: Swift.Int) -> Swift.String)
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: TrustID.URLEncoding.BoolEncoding, b: TrustID.URLEncoding.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: TrustID.URLEncoding {
    get
  }
  public static var queryString: TrustID.URLEncoding {
    get
  }
  public static var httpBody: TrustID.URLEncoding {
    get
  }
  public let destination: TrustID.URLEncoding.Destination
  public let arrayEncoding: TrustID.URLEncoding.ArrayEncoding
  public let boolEncoding: TrustID.URLEncoding.BoolEncoding
  public init(destination: TrustID.URLEncoding.Destination = .methodDependent, arrayEncoding: TrustID.URLEncoding.ArrayEncoding = .brackets, boolEncoding: TrustID.URLEncoding.BoolEncoding = .numeric)
  public func encode(_ urlRequest: any TrustID.URLRequestConvertible, with parameters: TrustID.Parameters?) throws -> Foundation.URLRequest
  public func queryComponents(fromKey key: Swift.String, value: Any) -> [(Swift.String, Swift.String)]
  public func escape(_ string: Swift.String) -> Swift.String
}
public struct JSONEncoding : TrustID.ParameterEncoding {
  public enum Error : Swift.Error {
    case invalidJSONObject
    public static func == (a: TrustID.JSONEncoding.Error, b: TrustID.JSONEncoding.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: TrustID.JSONEncoding {
    get
  }
  public static var prettyPrinted: TrustID.JSONEncoding {
    get
  }
  public let options: Foundation.JSONSerialization.WritingOptions
  public init(options: Foundation.JSONSerialization.WritingOptions = [])
  public func encode(_ urlRequest: any TrustID.URLRequestConvertible, with parameters: TrustID.Parameters?) throws -> Foundation.URLRequest
  public func encode(_ urlRequest: any TrustID.URLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> Foundation.URLRequest
}
extension TrustID.JSONEncoding.Error {
  public var localizedDescription: Swift.String {
    get
  }
}
public protocol CachedResponseHandler {
  func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
public struct ResponseCacher {
  public enum Behavior {
    case cache
    case doNotCache
    case modify((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)
  }
  public static let cache: TrustID.ResponseCacher
  public static let doNotCache: TrustID.ResponseCacher
  public let behavior: TrustID.ResponseCacher.Behavior
  public init(behavior: TrustID.ResponseCacher.Behavior)
}
extension TrustID.ResponseCacher : TrustID.CachedResponseHandler {
  public func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension TrustID.CachedResponseHandler where Self == TrustID.ResponseCacher {
  public static var cache: TrustID.ResponseCacher {
    get
  }
  public static var doNotCache: TrustID.ResponseCacher {
    get
  }
  public static func modify(using closure: @escaping ((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)) -> TrustID.ResponseCacher
}
extension TrustID.LottieAnimationView {
  @_Concurrency.MainActor @preconcurrency convenience public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, imageProvider: (any TrustID.AnimationImageProvider)? = nil, animationCache: (any TrustID.AnimationCacheProvider)? = LottieAnimationCache.shared, configuration: TrustID.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency convenience public init(filePath: Swift.String, imageProvider: (any TrustID.AnimationImageProvider)? = nil, animationCache: (any TrustID.AnimationCacheProvider)? = LottieAnimationCache.shared, configuration: TrustID.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency convenience public init(url: Foundation.URL, imageProvider: (any TrustID.AnimationImageProvider)? = nil, session: Foundation.URLSession = .shared, closure: @escaping TrustID.LottieAnimationView.DownloadClosure, animationCache: (any TrustID.AnimationCacheProvider)? = LottieAnimationCache.shared, configuration: TrustID.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency convenience public init(asset name: Swift.String, bundle: Foundation.Bundle = Bundle.main, imageProvider: (any TrustID.AnimationImageProvider)? = nil, animationCache: (any TrustID.AnimationCacheProvider)? = LottieAnimationCache.shared, configuration: TrustID.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency convenience public init(dotLottieName name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationId: Swift.String? = nil, dotLottieCache: (any TrustID.DotLottieCacheProvider)? = DotLottieCache.sharedCache, configuration: TrustID.LottieConfiguration = .shared, completion: ((TrustID.LottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency convenience public init(dotLottieFilePath filePath: Swift.String, animationId: Swift.String? = nil, dotLottieCache: (any TrustID.DotLottieCacheProvider)? = DotLottieCache.sharedCache, configuration: TrustID.LottieConfiguration = .shared, completion: ((TrustID.LottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency convenience public init(dotLottieUrl url: Foundation.URL, animationId: Swift.String? = nil, dotLottieCache: (any TrustID.DotLottieCacheProvider)? = DotLottieCache.sharedCache, configuration: TrustID.LottieConfiguration = .shared, session: Foundation.URLSession = .shared, completion: ((TrustID.LottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  @_Concurrency.MainActor @preconcurrency convenience public init(dotLottieAsset name: Swift.String, bundle: Foundation.Bundle = Bundle.main, animationId: Swift.String? = nil, dotLottieCache: (any TrustID.DotLottieCacheProvider)? = DotLottieCache.sharedCache, configuration: TrustID.LottieConfiguration = .shared, completion: ((TrustID.LottieAnimationView, (any Swift.Error)?) -> Swift.Void)? = nil)
  public typealias DownloadClosure = ((any Swift.Error)?) -> Swift.Void
}
infix operator +| : DefaultPrecedence
infix operator +- : DefaultPrecedence
public enum DecodingStrategy : Swift.Hashable {
  case legacyCodable
  case dictionaryBased
  public static func == (a: TrustID.DecodingStrategy, b: TrustID.DecodingStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class ChipAuthenticationInfo : TrustID.SecurityInfo {
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getKeyId() -> Swift.Int
  public static func toKeyAgreementAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toCipherAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toKeyLength(oid: Swift.String) throws -> Swift.Int
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup7 : TrustID.DataGroup {
  public var imageData: [Swift.UInt8] {
    get
  }
  @objc deinit
}
public protocol ParameterEncoder {
  func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
}
open class JSONParameterEncoder : TrustID.ParameterEncoder {
  public static var `default`: TrustID.JSONParameterEncoder {
    get
  }
  public static var prettyPrinted: TrustID.JSONParameterEncoder {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var sortedKeys: TrustID.JSONParameterEncoder {
    get
  }
  final public let encoder: Foundation.JSONEncoder
  public init(encoder: Foundation.JSONEncoder = JSONEncoder())
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
extension TrustID.ParameterEncoder where Self == TrustID.JSONParameterEncoder {
  public static var json: TrustID.JSONParameterEncoder {
    get
  }
  public static func json(encoder: Foundation.JSONEncoder = JSONEncoder()) -> TrustID.JSONParameterEncoder
}
open class URLEncodedFormParameterEncoder : TrustID.ParameterEncoder {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: TrustID.URLEncodedFormParameterEncoder.Destination, b: TrustID.URLEncodedFormParameterEncoder.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: TrustID.URLEncodedFormParameterEncoder {
    get
  }
  final public let encoder: TrustID.URLEncodedFormEncoder
  final public let destination: TrustID.URLEncodedFormParameterEncoder.Destination
  public init(encoder: TrustID.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: TrustID.URLEncodedFormParameterEncoder.Destination = .methodDependent)
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
extension TrustID.ParameterEncoder where Self == TrustID.URLEncodedFormParameterEncoder {
  public static var urlEncodedForm: TrustID.URLEncodedFormParameterEncoder {
    get
  }
  public static func urlEncodedForm(encoder: TrustID.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: TrustID.URLEncodedFormParameterEncoder.Destination = .methodDependent) -> TrustID.URLEncodedFormParameterEncoder
}
@available(iOS 13, macOS 10.15, *)
public class ASN1Item : Swift.CustomDebugStringConvertible {
  public init(line: Swift.String)
  public func getChild(_ child: Swift.Int) -> TrustID.ASN1Item?
  public func getNumberOfChildren() -> Swift.Int
  public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public class SimpleASN1DumpParser {
  public init()
  public func parse(data: Foundation.Data) throws -> TrustID.ASN1Item
  public func test()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers public class LottieAnimationLayer : QuartzCore.CALayer {
  public init(animation: TrustID.LottieAnimation?, imageProvider: (any TrustID.AnimationImageProvider)? = nil, textProvider: any TrustID.AnimationKeypathTextProvider = DefaultTextProvider(), fontProvider: any TrustID.AnimationFontProvider = DefaultFontProvider(), configuration: TrustID.LottieConfiguration = .shared, logger: TrustID.LottieLogger = .shared)
  public init(dotLottie: TrustID.DotLottieFile?, animationId: Swift.String? = nil, textProvider: any TrustID.AnimationKeypathTextProvider = DefaultTextProvider(), fontProvider: any TrustID.AnimationFontProvider = DefaultFontProvider(), configuration: TrustID.LottieConfiguration = .shared, logger: TrustID.LottieLogger = .shared)
  public init(configuration: TrustID.LottieConfiguration = .shared, logger: TrustID.LottieLogger = .shared)
  open func play(completion: TrustID.LottieCompletionBlock? = nil)
  open func play(fromProgress: TrustID.AnimationProgressTime? = nil, toProgress: TrustID.AnimationProgressTime, loopMode: TrustID.LottieLoopMode? = nil, completion: TrustID.LottieCompletionBlock? = nil)
  open func play(fromFrame: TrustID.AnimationFrameTime? = nil, toFrame: TrustID.AnimationFrameTime, loopMode: TrustID.LottieLoopMode? = nil, completion: TrustID.LottieCompletionBlock? = nil)
  open func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: TrustID.LottieLoopMode? = nil, completion: TrustID.LottieCompletionBlock? = nil)
  open func play(marker: Swift.String, loopMode: TrustID.LottieLoopMode? = nil, completion: TrustID.LottieCompletionBlock? = nil)
  open func play(markers: [Swift.String], completion: TrustID.LottieCompletionBlock? = nil)
  open func stop()
  open func pause()
  open func pause(at state: TrustID.LottiePlaybackMode.PausedState)
  @available(*, deprecated, renamed: "setPlaybackMode(_:completion:)", message: "Will be removed in a future major release.")
  open func play(_ playbackMode: TrustID.LottiePlaybackMode, animationCompletionHandler: TrustID.LottieCompletionBlock? = nil)
  open func setPlaybackMode(_ playbackMode: TrustID.LottiePlaybackMode, completion: TrustID.LottieCompletionBlock? = nil)
  open func play(_ playbackMode: TrustID.LottiePlaybackMode.PlaybackMode, completion: TrustID.LottieCompletionBlock? = nil)
  public var currentPlaybackMode: TrustID.LottiePlaybackMode? {
    get
  }
  public var valueProviders: [TrustID.AnimationKeypath : any TrustID.AnyValueProvider] {
    get
  }
  public var animationLayerDidLoad: ((_ animationLayer: TrustID.LottieAnimationLayer, _ renderingEngine: TrustID.RenderingEngineOption) -> Swift.Void)?
  public var configuration: TrustID.LottieConfiguration {
    get
    set
  }
  public var animationLayer: QuartzCore.CALayer? {
    get
  }
  public var screenScale: CoreFoundation.CGFloat {
    get
    set
  }
  public var backgroundBehavior: TrustID.LottieBackgroundBehavior {
    get
    set
  }
  public var animation: TrustID.LottieAnimation? {
    get
    set
  }
  public var animationLoaded: ((_ animationLayer: TrustID.LottieAnimationLayer, _ animation: TrustID.LottieAnimation) -> Swift.Void)? {
    get
    set
  }
  public var imageProvider: any TrustID.AnimationImageProvider {
    get
    set
  }
  public var textProvider: any TrustID.AnimationKeypathTextProvider {
    get
    set
  }
  public var fontProvider: any TrustID.AnimationFontProvider {
    get
    set
  }
  public var maskAnimationToBounds: Swift.Bool {
    get
    set
  }
  public var isAnimationPlaying: Swift.Bool {
    get
  }
  public var loopMode: TrustID.LottieLoopMode {
    get
    set
  }
  public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  public var currentProgress: TrustID.AnimationProgressTime {
    get
    set
  }
  public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  public var currentFrame: TrustID.AnimationFrameTime {
    get
    set
  }
  public var realtimeAnimationFrame: TrustID.AnimationFrameTime {
    get
  }
  public var realtimeAnimationProgress: TrustID.AnimationProgressTime {
    get
  }
  public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  public var currentRenderingEngine: TrustID.RenderingEngine? {
    get
  }
  public var mainThreadRenderingEngineShouldForceDisplayUpdateOnEachFrame: Swift.Bool {
    get
    set
  }
  public func loadAnimation(_ animationId: Swift.String? = nil, from dotLottieFile: TrustID.DotLottieFile)
  public func loadAnimation(atIndex index: Swift.Int, from dotLottieFile: TrustID.DotLottieFile)
  public func reloadImages()
  public func forceDisplayUpdate()
  public func setValueProvider(_ valueProvider: any TrustID.AnyValueProvider, keypath: TrustID.AnimationKeypath)
  public func getValue(for keypath: TrustID.AnimationKeypath, atFrame: TrustID.AnimationFrameTime?) -> Any?
  public func getOriginalValue(for keypath: TrustID.AnimationKeypath, atFrame: TrustID.AnimationFrameTime?) -> Any?
  public func logHierarchyKeypaths()
  public func allHierarchyKeypaths() -> [Swift.String]
  public func convert(_ rect: CoreFoundation.CGRect, toLayerAt keypath: TrustID.AnimationKeypath?) -> CoreFoundation.CGRect?
  public func convert(_ point: CoreFoundation.CGPoint, toLayerAt keypath: TrustID.AnimationKeypath?) -> CoreFoundation.CGPoint?
  public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: TrustID.AnimationKeypath)
  public func progressTime(forMarker named: Swift.String) -> TrustID.AnimationProgressTime?
  public func frameTime(forMarker named: Swift.String) -> TrustID.AnimationFrameTime?
  public func durationFrameTime(forMarker named: Swift.String) -> TrustID.AnimationFrameTime?
  public func updateAnimationForBackgroundState()
  public func updateAnimationForForegroundState(wasWaitingToPlayAnimation: Swift.Bool)
  @objc deinit
}
@_hasMissingDesignatedInitializers open class NetworkReachabilityManager {
  public enum NetworkReachabilityStatus {
    case unknown
    case notReachable
    case reachable(TrustID.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType)
    public enum ConnectionType {
      case ethernetOrWiFi
      case cellular
      public static func == (a: TrustID.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType, b: TrustID.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
  public typealias Listener = (TrustID.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Void
  public static let `default`: TrustID.NetworkReachabilityManager?
  open var isReachable: Swift.Bool {
    get
  }
  open var isReachableOnCellular: Swift.Bool {
    get
  }
  open var isReachableOnEthernetOrWiFi: Swift.Bool {
    get
  }
  final public let reachabilityQueue: Dispatch.DispatchQueue
  open var flags: SystemConfiguration.SCNetworkReachabilityFlags? {
    get
  }
  open var status: TrustID.NetworkReachabilityManager.NetworkReachabilityStatus {
    get
  }
  convenience public init?(host: Swift.String)
  convenience public init?()
  @objc deinit
  @discardableResult
  open func startListening(onQueue queue: Dispatch.DispatchQueue = .main, onUpdatePerforming listener: @escaping TrustID.NetworkReachabilityManager.Listener) -> Swift.Bool
  open func stopListening()
}
extension TrustID.NetworkReachabilityManager.NetworkReachabilityStatus : Swift.Equatable {
  public static func == (a: TrustID.NetworkReachabilityManager.NetworkReachabilityStatus, b: TrustID.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Bool
}
final public class URLEncodedFormEncoder {
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    case custom((_ key: Swift.String, _ index: Swift.Int) -> Swift.String)
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: TrustID.URLEncodedFormEncoder.BoolEncoding, b: TrustID.URLEncodedFormEncoder.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum DataEncoding {
    case deferredToData
    case base64
    case custom((Foundation.Data) throws -> Swift.String)
  }
  public enum DateEncoding {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    case iso8601
    case formatted(Foundation.DateFormatter)
    case custom((Foundation.Date) throws -> Swift.String)
  }
  public enum KeyEncoding {
    case useDefaultKeys
    case convertToSnakeCase
    case convertToKebabCase
    case capitalized
    case uppercased
    case lowercased
    case custom((Swift.String) -> Swift.String)
  }
  public struct KeyPathEncoding {
    public static let brackets: TrustID.URLEncodedFormEncoder.KeyPathEncoding
    public static let dots: TrustID.URLEncodedFormEncoder.KeyPathEncoding
    public init(encoding: @escaping (_ subkey: Swift.String) -> Swift.String)
  }
  public struct NilEncoding {
    public static let dropKey: TrustID.URLEncodedFormEncoder.NilEncoding
    public static let dropValue: TrustID.URLEncodedFormEncoder.NilEncoding
    public static let null: TrustID.URLEncodedFormEncoder.NilEncoding
    public init(encoding: @escaping () -> Swift.String?)
  }
  public enum SpaceEncoding {
    case percentEscaped
    case plusReplaced
    public static func == (a: TrustID.URLEncodedFormEncoder.SpaceEncoding, b: TrustID.URLEncodedFormEncoder.SpaceEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Error : Swift.Error {
    case invalidRootObject(Swift.String)
  }
  final public let alphabetizeKeyValuePairs: Swift.Bool
  final public let arrayEncoding: TrustID.URLEncodedFormEncoder.ArrayEncoding
  final public let boolEncoding: TrustID.URLEncodedFormEncoder.BoolEncoding
  final public let dataEncoding: TrustID.URLEncodedFormEncoder.DataEncoding
  final public let dateEncoding: TrustID.URLEncodedFormEncoder.DateEncoding
  final public let keyEncoding: TrustID.URLEncodedFormEncoder.KeyEncoding
  final public let keyPathEncoding: TrustID.URLEncodedFormEncoder.KeyPathEncoding
  final public let nilEncoding: TrustID.URLEncodedFormEncoder.NilEncoding
  final public let spaceEncoding: TrustID.URLEncodedFormEncoder.SpaceEncoding
  final public var allowedCharacters: Foundation.CharacterSet
  public init(alphabetizeKeyValuePairs: Swift.Bool = true, arrayEncoding: TrustID.URLEncodedFormEncoder.ArrayEncoding = .brackets, boolEncoding: TrustID.URLEncodedFormEncoder.BoolEncoding = .numeric, dataEncoding: TrustID.URLEncodedFormEncoder.DataEncoding = .base64, dateEncoding: TrustID.URLEncodedFormEncoder.DateEncoding = .deferredToDate, keyEncoding: TrustID.URLEncodedFormEncoder.KeyEncoding = .useDefaultKeys, keyPathEncoding: TrustID.URLEncodedFormEncoder.KeyPathEncoding = .brackets, nilEncoding: TrustID.URLEncodedFormEncoder.NilEncoding = .dropKey, spaceEncoding: TrustID.URLEncodedFormEncoder.SpaceEncoding = .percentEscaped, allowedCharacters: Foundation.CharacterSet = .afURLQueryAllowed)
  final public func encode(_ value: any Swift.Encodable) throws -> Swift.String
  final public func encode(_ value: any Swift.Encodable) throws -> Foundation.Data
  @objc deinit
}
extension Foundation.CharacterSet {
  public static let afURLQueryAllowed: Foundation.CharacterSet
}
public struct HTTPHeaders {
  public init()
  public init(_ headers: [TrustID.HTTPHeader])
  public init(_ dictionary: [Swift.String : Swift.String])
  public mutating func add(name: Swift.String, value: Swift.String)
  public mutating func add(_ header: TrustID.HTTPHeader)
  public mutating func update(name: Swift.String, value: Swift.String)
  public mutating func update(_ header: TrustID.HTTPHeader)
  public mutating func remove(name: Swift.String)
  public mutating func sort()
  public func sorted() -> TrustID.HTTPHeaders
  public func value(for name: Swift.String) -> Swift.String?
  public subscript(name: Swift.String) -> Swift.String? {
    get
    set
  }
  public var dictionary: [Swift.String : Swift.String] {
    get
  }
}
extension TrustID.HTTPHeaders : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Swift.String)...)
  public typealias Key = Swift.String
  public typealias Value = Swift.String
}
extension TrustID.HTTPHeaders : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: TrustID.HTTPHeader...)
  public typealias ArrayLiteralElement = TrustID.HTTPHeader
}
extension TrustID.HTTPHeaders : Swift.Sequence {
  public func makeIterator() -> Swift.IndexingIterator<[TrustID.HTTPHeader]>
  public typealias Element = Swift.IndexingIterator<[TrustID.HTTPHeader]>.Element
  public typealias Iterator = Swift.IndexingIterator<[TrustID.HTTPHeader]>
}
extension TrustID.HTTPHeaders : Swift.Collection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(position: Swift.Int) -> TrustID.HTTPHeader {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<TrustID.HTTPHeaders>
  public typealias SubSequence = Swift.Slice<TrustID.HTTPHeaders>
}
extension TrustID.HTTPHeaders : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct HTTPHeader : Swift.Hashable {
  public let name: Swift.String
  public let value: Swift.String
  public init(name: Swift.String, value: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TrustID.HTTPHeader, b: TrustID.HTTPHeader) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension TrustID.HTTPHeader : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension TrustID.HTTPHeader {
  public static func accept(_ value: Swift.String) -> TrustID.HTTPHeader
  public static func acceptCharset(_ value: Swift.String) -> TrustID.HTTPHeader
  public static func acceptLanguage(_ value: Swift.String) -> TrustID.HTTPHeader
  public static func acceptEncoding(_ value: Swift.String) -> TrustID.HTTPHeader
  public static func authorization(username: Swift.String, password: Swift.String) -> TrustID.HTTPHeader
  public static func authorization(bearerToken: Swift.String) -> TrustID.HTTPHeader
  public static func authorization(_ value: Swift.String) -> TrustID.HTTPHeader
  public static func contentDisposition(_ value: Swift.String) -> TrustID.HTTPHeader
  public static func contentEncoding(_ value: Swift.String) -> TrustID.HTTPHeader
  public static func contentType(_ value: Swift.String) -> TrustID.HTTPHeader
  public static func userAgent(_ value: Swift.String) -> TrustID.HTTPHeader
}
extension TrustID.HTTPHeaders {
  public static let `default`: TrustID.HTTPHeaders
}
extension TrustID.HTTPHeader {
  public static let defaultAcceptEncoding: TrustID.HTTPHeader
  public static let defaultAcceptLanguage: TrustID.HTTPHeader
  public static let defaultUserAgent: TrustID.HTTPHeader
}
extension Foundation.URLRequest {
  public var headers: TrustID.HTTPHeaders {
    get
    set
  }
}
extension Foundation.HTTPURLResponse {
  public var headers: TrustID.HTTPHeaders {
    get
  }
}
extension Foundation.URLSessionConfiguration {
  public var headers: TrustID.HTTPHeaders {
    get
    set
  }
}
public struct DotLottieConfiguration {
  public var id: Swift.String
  public var loopMode: TrustID.LottieLoopMode
  public var speed: Swift.Double
  public var imageProvider: (any TrustID.AnimationImageProvider)? {
    get
  }
}
public struct DotLottieConfigurationComponents : Swift.OptionSet {
  public init(rawValue: Swift.Int)
  public static let imageProvider: TrustID.DotLottieConfigurationComponents
  public static let loopMode: TrustID.DotLottieConfigurationComponents
  public static let animationSpeed: TrustID.DotLottieConfigurationComponents
  public static let all: TrustID.DotLottieConfigurationComponents
  public static let none: TrustID.DotLottieConfigurationComponents
  public let rawValue: Swift.Int
  public typealias ArrayLiteralElement = TrustID.DotLottieConfigurationComponents
  public typealias Element = TrustID.DotLottieConfigurationComponents
  public typealias RawValue = Swift.Int
}
public enum LottieBackgroundBehavior {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  case continuePlaying
  public static func `default`(for renderingEngine: TrustID.RenderingEngine) -> TrustID.LottieBackgroundBehavior
  public static func == (a: TrustID.LottieBackgroundBehavior, b: TrustID.LottieBackgroundBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum LottieLoopMode : Swift.Hashable {
  case playOnce
  case loop
  case autoReverse
  case `repeat`(Swift.Float)
  case repeatBackwards(Swift.Float)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension TrustID.LottieLoopMode : Swift.Equatable {
  public static func == (lhs: TrustID.LottieLoopMode, rhs: TrustID.LottieLoopMode) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor @preconcurrency open class LottieAnimationView : TrustID.LottieAnimationViewBase {
  @_Concurrency.MainActor @preconcurrency public init(animation: TrustID.LottieAnimation?, imageProvider: (any TrustID.AnimationImageProvider)? = nil, textProvider: any TrustID.AnimationKeypathTextProvider = DefaultTextProvider(), fontProvider: any TrustID.AnimationFontProvider = DefaultFontProvider(), configuration: TrustID.LottieConfiguration = .shared, logger: TrustID.LottieLogger = .shared)
  @_Concurrency.MainActor @preconcurrency public init(dotLottie: TrustID.DotLottieFile?, animationId: Swift.String? = nil, textProvider: any TrustID.AnimationKeypathTextProvider = DefaultTextProvider(), fontProvider: any TrustID.AnimationFontProvider = DefaultFontProvider(), configuration: TrustID.LottieConfiguration = .shared, logger: TrustID.LottieLogger = .shared)
  @_Concurrency.MainActor @preconcurrency public init(configuration: TrustID.LottieConfiguration = .shared, logger: TrustID.LottieLogger = .shared)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency open func play(_ mode: TrustID.LottiePlaybackMode.PlaybackMode, completion: TrustID.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(completion: TrustID.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(fromProgress: TrustID.AnimationProgressTime? = nil, toProgress: TrustID.AnimationProgressTime, loopMode: TrustID.LottieLoopMode? = nil, completion: TrustID.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(fromFrame: TrustID.AnimationFrameTime? = nil, toFrame: TrustID.AnimationFrameTime, loopMode: TrustID.LottieLoopMode? = nil, completion: TrustID.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: TrustID.LottieLoopMode? = nil, completion: TrustID.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(marker: Swift.String, loopMode: TrustID.LottieLoopMode? = nil, completion: TrustID.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func play(markers: [Swift.String], completion: TrustID.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func stop()
  @_Concurrency.MainActor @preconcurrency open func pause()
  @available(*, deprecated, renamed: "setPlaybackMode(_:completion:)", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor @preconcurrency open func play(_ playbackMode: TrustID.LottiePlaybackMode, animationCompletionHandler: TrustID.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency open func setPlaybackMode(_ playbackMode: TrustID.LottiePlaybackMode, completion: TrustID.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor @preconcurrency public var animateLayoutChangesWithCurrentCoreAnimationContext: Swift.Bool
  @_Concurrency.MainActor @preconcurrency public var configuration: TrustID.LottieConfiguration {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var valueProviders: [TrustID.AnimationKeypath : any TrustID.AnyValueProvider] {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var backgroundBehavior: TrustID.LottieBackgroundBehavior {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var animation: TrustID.LottieAnimation? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var animationLoaded: ((_ animationView: TrustID.LottieAnimationView, _ animation: TrustID.LottieAnimation) -> Swift.Void)? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var imageProvider: any TrustID.AnimationImageProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var textProvider: any TrustID.AnimationKeypathTextProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var fontProvider: any TrustID.AnimationFontProvider {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var maskAnimationToBounds: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var isAnimationPlaying: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var isAnimationQueued: Swift.Bool {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var loopMode: TrustID.LottieLoopMode {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var currentProgress: TrustID.AnimationProgressTime {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var currentFrame: TrustID.AnimationFrameTime {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var realtimeAnimationFrame: TrustID.AnimationFrameTime {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var realtimeAnimationProgress: TrustID.AnimationProgressTime {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public var viewportFrame: CoreFoundation.CGRect? {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor @preconcurrency public var currentRenderingEngine: TrustID.RenderingEngine? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var currentPlaybackMode: TrustID.LottiePlaybackMode? {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var mainThreadRenderingEngineShouldForceDisplayUpdateOnEachFrame: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func loadAnimation(_ animationId: Swift.String? = nil, from dotLottieFile: TrustID.DotLottieFile)
  @_Concurrency.MainActor @preconcurrency public func loadAnimation(atIndex index: Swift.Int, from dotLottieFile: TrustID.DotLottieFile)
  @_Concurrency.MainActor @preconcurrency public func reloadImages()
  @_Concurrency.MainActor @preconcurrency public func forceDisplayUpdate()
  @_Concurrency.MainActor @preconcurrency public func setValueProvider(_ valueProvider: any TrustID.AnyValueProvider, keypath: TrustID.AnimationKeypath)
  @_Concurrency.MainActor @preconcurrency public func getValue(for keypath: TrustID.AnimationKeypath, atFrame: TrustID.AnimationFrameTime?) -> Any?
  @_Concurrency.MainActor @preconcurrency public func getOriginalValue(for keypath: TrustID.AnimationKeypath, atFrame: TrustID.AnimationFrameTime?) -> Any?
  @_Concurrency.MainActor @preconcurrency public func logHierarchyKeypaths()
  @_Concurrency.MainActor @preconcurrency public func allHierarchyKeypaths() -> [Swift.String]
  @_Concurrency.MainActor @preconcurrency public func addSubview(_ subview: TrustID.AnimationSubview, forLayerAt keypath: TrustID.AnimationKeypath)
  @_Concurrency.MainActor @preconcurrency public func convert(_ rect: CoreFoundation.CGRect, toLayerAt keypath: TrustID.AnimationKeypath?) -> CoreFoundation.CGRect?
  @_Concurrency.MainActor @preconcurrency public func convert(_ point: CoreFoundation.CGPoint, toLayerAt keypath: TrustID.AnimationKeypath?) -> CoreFoundation.CGPoint?
  @_Concurrency.MainActor @preconcurrency public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: TrustID.AnimationKeypath)
  @_Concurrency.MainActor @preconcurrency public func progressTime(forMarker named: Swift.String) -> TrustID.AnimationProgressTime?
  @_Concurrency.MainActor @preconcurrency public func frameTime(forMarker named: Swift.String) -> TrustID.AnimationFrameTime?
  @_Concurrency.MainActor @preconcurrency public func durationFrameTime(forMarker named: Swift.String) -> TrustID.AnimationFrameTime?
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup2 : TrustID.DataGroup {
  public var nrImages: Swift.Int {
    get
  }
  public var versionNumber: Swift.Int {
    get
  }
  public var lengthOfRecord: Swift.Int {
    get
  }
  public var numberOfFacialImages: Swift.Int {
    get
  }
  public var facialRecordDataLength: Swift.Int {
    get
  }
  public var nrFeaturePoints: Swift.Int {
    get
  }
  public var gender: Swift.Int {
    get
  }
  public var eyeColor: Swift.Int {
    get
  }
  public var hairColor: Swift.Int {
    get
  }
  public var featureMask: Swift.Int {
    get
  }
  public var expression: Swift.Int {
    get
  }
  public var poseAngle: Swift.Int {
    get
  }
  public var poseAngleUncertainty: Swift.Int {
    get
  }
  public var faceImageType: Swift.Int {
    get
  }
  public var imageDataType: Swift.Int {
    get
  }
  public var imageWidth: Swift.Int {
    get
  }
  public var imageHeight: Swift.Int {
    get
  }
  public var imageColorSpace: Swift.Int {
    get
  }
  public var sourceType: Swift.Int {
    get
  }
  public var deviceType: Swift.Int {
    get
  }
  public var quality: Swift.Int {
    get
  }
  public var imageData: [Swift.UInt8] {
    get
  }
  @objc deinit
}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
@_Concurrency.MainActor @preconcurrency public struct LottieView<Placeholder> where Placeholder : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public init(animation: TrustID.LottieAnimation?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(dotLottieFile: TrustID.DotLottieFile?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(_ loadAnimation: @escaping () async throws -> TrustID.LottieAnimation?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(_ loadAnimation: @escaping () async throws -> TrustID.LottieAnimation?, @SwiftUICore.ViewBuilder placeholder: @escaping (() -> Placeholder))
  @_Concurrency.MainActor @preconcurrency public init(_ loadDotLottieFile: @escaping () async throws -> TrustID.DotLottieFile?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(_ loadDotLottieFile: @escaping () async throws -> TrustID.DotLottieFile?, @SwiftUICore.ViewBuilder placeholder: @escaping (() -> Placeholder))
  @_Concurrency.MainActor @preconcurrency public init(_ loadAnimation: @escaping () async throws -> TrustID.LottieAnimationSource?) where Placeholder == SwiftUICore.EmptyView
  @_Concurrency.MainActor @preconcurrency public init(_ loadAnimation: @escaping () async throws -> TrustID.LottieAnimationSource?, @SwiftUICore.ViewBuilder placeholder: @escaping () -> Placeholder)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func configure(_ configure: @escaping (TrustID.LottieAnimationView) -> Swift.Void) -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func resizable() -> TrustID.LottieView<Placeholder>
  @available(*, deprecated, renamed: "playing()", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor @preconcurrency public func play() -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func looping() -> TrustID.LottieView<Placeholder>
  @available(*, deprecated, renamed: "playing(_:)", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor @preconcurrency public func play(loopMode: TrustID.LottieLoopMode = .playOnce) -> TrustID.LottieView<Placeholder>
  @available(*, deprecated, renamed: "playbackMode(_:)", message: "Will be removed in a future major release.")
  @_Concurrency.MainActor @preconcurrency public func play(_ playbackMode: TrustID.LottiePlaybackMode) -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func playing(_ mode: TrustID.LottiePlaybackMode.PlaybackMode) -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func playing(loopMode: TrustID.LottieLoopMode) -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func playing() -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func paused(at state: TrustID.LottiePlaybackMode.PausedState = .currentFrame) -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func playbackMode(_ playbackMode: TrustID.LottiePlaybackMode) -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func animationSpeed(_ animationSpeed: Swift.Double) -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func animationDidLoad(_ animationDidLoad: @escaping (TrustID.LottieAnimationSource) -> Swift.Void) -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func animationDidFinish(_ animationCompletionHandler: TrustID.LottieCompletionBlock?) -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func backgroundBehavior(_ value: TrustID.LottieBackgroundBehavior) -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func accessibilityLabel(_ accessibilityLabel: Swift.String?) -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func configuration(_ configuration: TrustID.LottieConfiguration) -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func logger(_ logger: TrustID.LottieLogger) -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func imageProvider<ImageProvider>(_ imageProvider: ImageProvider) -> TrustID.LottieView<Placeholder> where ImageProvider : Swift.Equatable, ImageProvider : TrustID.AnimationImageProvider
  @_Concurrency.MainActor @preconcurrency public func textProvider<TextProvider>(_ textProvider: TextProvider) -> TrustID.LottieView<Placeholder> where TextProvider : Swift.Equatable, TextProvider : TrustID.AnimationKeypathTextProvider
  @_Concurrency.MainActor @preconcurrency public func fontProvider<FontProvider>(_ fontProvider: FontProvider) -> TrustID.LottieView<Placeholder> where FontProvider : Swift.Equatable, FontProvider : TrustID.AnimationFontProvider
  @_Concurrency.MainActor @preconcurrency public func valueProvider<ValueProvider>(_ valueProvider: ValueProvider, for keypath: TrustID.AnimationKeypath) -> TrustID.LottieView<Placeholder> where ValueProvider : Swift.Equatable, ValueProvider : TrustID.AnyValueProvider
  @_Concurrency.MainActor @preconcurrency public func currentProgress(_ currentProgress: TrustID.AnimationProgressTime?) -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func currentFrame(_ currentFrame: TrustID.AnimationFrameTime?) -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func currentTime(_ currentTime: Foundation.TimeInterval?) -> TrustID.LottieView<Placeholder>
  @_Concurrency.MainActor @preconcurrency public func reloadAnimationTrigger(_ value: some Equatable, showPlaceholder: Swift.Bool = true) -> TrustID.LottieView<Placeholder>
  @available(iOS 15.0, tvOS 15.0, macOS 12.0, *)
  @_Concurrency.MainActor @preconcurrency public func getRealtimeAnimationProgress(_ realtimeAnimationProgress: SwiftUICore.Binding<TrustID.AnimationProgressTime>?) -> some SwiftUICore.View
  
  @available(iOS 15.0, tvOS 15.0, macOS 12.0, *)
  @_Concurrency.MainActor @preconcurrency public func getRealtimeAnimationFrame(_ realtimeAnimationFrame: SwiftUICore.Binding<TrustID.AnimationFrameTime>?) -> some SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func dotLottieConfigurationComponents(_ dotLottieConfigurationComponents: TrustID.DotLottieConfigurationComponents) -> TrustID.LottieView<Placeholder>
  @available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
  public typealias Body = @_opaqueReturnTypeOf("$s7TrustID10LottieViewV4bodyQrvp", 0) __<Placeholder>
}
extension TrustID.LottieAnimation {
  public typealias DownloadClosure = (TrustID.LottieAnimation?) -> Swift.Void
  final public var duration: Foundation.TimeInterval {
    get
  }
  final public var bounds: CoreFoundation.CGRect {
    get
  }
  final public var size: CoreFoundation.CGSize {
    get
  }
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationCache: (any TrustID.AnimationCacheProvider)? = LottieAnimationCache.shared) -> TrustID.LottieAnimation?
  public static func filepath(_ filepath: Swift.String, animationCache: (any TrustID.AnimationCacheProvider)? = LottieAnimationCache.shared) -> TrustID.LottieAnimation?
  public static func asset(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, animationCache: (any TrustID.AnimationCacheProvider)? = LottieAnimationCache.shared) -> TrustID.LottieAnimation?
  public static func from(data: Foundation.Data, strategy: TrustID.DecodingStrategy = LottieConfiguration.shared.decodingStrategy) throws -> TrustID.LottieAnimation
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, animationCache: (any TrustID.AnimationCacheProvider)? = LottieAnimationCache.shared) async -> TrustID.LottieAnimation?
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, closure: @escaping TrustID.LottieAnimation.DownloadClosure, animationCache: (any TrustID.AnimationCacheProvider)? = LottieAnimationCache.shared)
  final public func progressTime(forMarker named: Swift.String) -> TrustID.AnimationProgressTime?
  final public func frameTime(forMarker named: Swift.String) -> TrustID.AnimationFrameTime?
  final public func durationFrameTime(forMarker named: Swift.String) -> TrustID.AnimationFrameTime?
  final public func progressTime(forFrame frameTime: TrustID.AnimationFrameTime, clamped: Swift.Bool = true) -> TrustID.AnimationProgressTime
  final public func frameTime(forProgress progressTime: TrustID.AnimationProgressTime) -> TrustID.AnimationFrameTime
  final public func time(forFrame frameTime: TrustID.AnimationFrameTime) -> Foundation.TimeInterval
  final public func frameTime(forTime time: Foundation.TimeInterval) -> TrustID.AnimationFrameTime
}
extension Foundation.Bundle : @unchecked Swift.Sendable {
}
public struct AlamofireExtension<ExtendedType> {
  public var type: ExtendedType {
    get
  }
  public init(_ type: ExtendedType)
}
public protocol AlamofireExtended {
  associatedtype ExtendedType
  static var af: TrustID.AlamofireExtension<Self.ExtendedType>.Type { get set }
  var af: TrustID.AlamofireExtension<Self.ExtendedType> { get set }
}
extension TrustID.AlamofireExtended {
  public static var af: TrustID.AlamofireExtension<Self>.Type {
    get
    set
  }
  public var af: TrustID.AlamofireExtension<Self> {
    get
    set
  }
}
public protocol AnimationCacheProvider : AnyObject, Swift.Sendable {
  func animation(forKey: Swift.String) -> TrustID.LottieAnimation?
  func setAnimation(_ animation: TrustID.LottieAnimation, forKey: Swift.String)
  func clearCache()
}
public class FilepathImageProvider : TrustID.AnimationImageProvider {
  public init(filepath: Swift.String, contentsGravity: QuartzCore.CALayerContentsGravity = .resize)
  public init(filepath: Foundation.URL, contentsGravity: QuartzCore.CALayerContentsGravity = .resize)
  public func imageForAsset(asset: TrustID.ImageAsset) -> CoreGraphics.CGImage?
  public func contentsGravity(for _: TrustID.ImageAsset) -> QuartzCore.CALayerContentsGravity
  @objc deinit
}
extension TrustID.FilepathImageProvider : Swift.Equatable {
  public static func == (lhs: TrustID.FilepathImageProvider, rhs: TrustID.FilepathImageProvider) -> Swift.Bool
}
final public class SizeValueProvider {
  public init(block: @escaping TrustID.SizeValueProvider.SizeValueBlock)
  public init(_ size: CoreFoundation.CGSize)
  public typealias SizeValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  final public var size: CoreFoundation.CGSize {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: TrustID.ValueProviderStorage<TrustID.LottieVector3D> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension TrustID.SizeValueProvider : Swift.Equatable {
  public static func == (lhs: TrustID.SizeValueProvider, rhs: TrustID.SizeValueProvider) -> Swift.Bool
}
public protocol DataResponseSerializerProtocol {
  associatedtype SerializedObject
  func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> Self.SerializedObject
}
public protocol DownloadResponseSerializerProtocol {
  associatedtype SerializedObject
  func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: (any Swift.Error)?) throws -> Self.SerializedObject
}
public protocol ResponseSerializer : TrustID.DataResponseSerializerProtocol, TrustID.DownloadResponseSerializerProtocol {
  var dataPreprocessor: any TrustID.DataPreprocessor { get }
  var emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> { get }
  var emptyResponseCodes: Swift.Set<Swift.Int> { get }
}
public protocol DataPreprocessor {
  func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct PassthroughPreprocessor : TrustID.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct GoogleXSSIPreprocessor : TrustID.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
extension TrustID.DataPreprocessor where Self == TrustID.PassthroughPreprocessor {
  public static var passthrough: TrustID.PassthroughPreprocessor {
    get
  }
}
extension TrustID.DataPreprocessor where Self == TrustID.GoogleXSSIPreprocessor {
  public static var googleXSSI: TrustID.GoogleXSSIPreprocessor {
    get
  }
}
extension TrustID.ResponseSerializer {
  public static var defaultDataPreprocessor: any TrustID.DataPreprocessor {
    get
  }
  public static var defaultEmptyRequestMethods: Swift.Set<TrustID.HTTPMethod> {
    get
  }
  public static var defaultEmptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public var dataPreprocessor: any TrustID.DataPreprocessor {
    get
  }
  public var emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> {
    get
  }
  public var emptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public func requestAllowsEmptyResponseData(_ request: Foundation.URLRequest?) -> Swift.Bool?
  public func responseAllowsEmptyResponseData(_ response: Foundation.HTTPURLResponse?) -> Swift.Bool?
  public func emptyResponseAllowed(forRequest request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?) -> Swift.Bool
}
extension TrustID.DownloadResponseSerializerProtocol where Self : TrustID.DataResponseSerializerProtocol {
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: (any Swift.Error)?) throws -> Self.SerializedObject
}
extension TrustID.DataRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (TrustID.AFDataResponse<Foundation.Data?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (TrustID.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : TrustID.DataResponseSerializerProtocol
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (TrustID.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : TrustID.ResponseSerializer
}
extension TrustID.DownloadRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (TrustID.AFDownloadResponse<Foundation.URL?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (TrustID.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : TrustID.DownloadResponseSerializerProtocol
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (TrustID.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : TrustID.ResponseSerializer
}
public struct URLResponseSerializer : TrustID.DownloadResponseSerializerProtocol {
  public init()
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: (any Swift.Error)?) throws -> Foundation.URL
  public typealias SerializedObject = Foundation.URL
}
extension TrustID.DownloadResponseSerializerProtocol where Self == TrustID.URLResponseSerializer {
  public static var url: TrustID.URLResponseSerializer {
    get
  }
}
extension TrustID.DownloadRequest {
  @discardableResult
  public func responseURL(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (TrustID.AFDownloadResponse<Foundation.URL>) -> Swift.Void) -> Self
}
final public class DataResponseSerializer : TrustID.ResponseSerializer {
  final public let dataPreprocessor: any TrustID.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<TrustID.HTTPMethod>
  public init(dataPreprocessor: any TrustID.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
  @objc deinit
}
extension TrustID.ResponseSerializer where Self == TrustID.DataResponseSerializer {
  public static var data: TrustID.DataResponseSerializer {
    get
  }
  public static func data(dataPreprocessor: any TrustID.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> TrustID.DataResponseSerializer
}
extension TrustID.DataRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any TrustID.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (TrustID.AFDataResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension TrustID.DownloadRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any TrustID.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (TrustID.AFDownloadResponse<Foundation.Data>) -> Swift.Void) -> Self
}
final public class StringResponseSerializer : TrustID.ResponseSerializer {
  final public let dataPreprocessor: any TrustID.DataPreprocessor
  final public let encoding: Swift.String.Encoding?
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<TrustID.HTTPMethod>
  public init(dataPreprocessor: any TrustID.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> Swift.String
  public typealias SerializedObject = Swift.String
  @objc deinit
}
extension TrustID.ResponseSerializer where Self == TrustID.StringResponseSerializer {
  public static var string: TrustID.StringResponseSerializer {
    get
  }
  public static func string(dataPreprocessor: any TrustID.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> TrustID.StringResponseSerializer
}
extension TrustID.DataRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any TrustID.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (TrustID.AFDataResponse<Swift.String>) -> Swift.Void) -> Self
}
extension TrustID.DownloadRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any TrustID.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (TrustID.AFDownloadResponse<Swift.String>) -> Swift.Void) -> Self
}
@available(*, deprecated, message: "JSONResponseSerializer deprecated and will be removed in Alamofire 6. Use DecodableResponseSerializer instead.")
final public class JSONResponseSerializer : TrustID.ResponseSerializer {
  final public let dataPreprocessor: any TrustID.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<TrustID.HTTPMethod>
  final public let options: Foundation.JSONSerialization.ReadingOptions
  public init(dataPreprocessor: any TrustID.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> Any
  @available(*, deprecated, message: "JSONResponseSerializer deprecated and will be removed in Alamofire 6. Use DecodableResponseSerializer instead.")
  public typealias SerializedObject = Any
  @objc deinit
}
extension TrustID.DataRequest {
  @available(*, deprecated, message: "responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.")
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any TrustID.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (TrustID.AFDataResponse<Any>) -> Swift.Void) -> Self
}
extension TrustID.DownloadRequest {
  @available(*, deprecated, message: "responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.")
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any TrustID.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (TrustID.AFDownloadResponse<Any>) -> Swift.Void) -> Self
}
public protocol EmptyResponse {
  static func emptyValue() -> Self
}
public struct Empty : Swift.Codable {
  public static let value: TrustID.Empty
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension TrustID.Empty : TrustID.EmptyResponse {
  public static func emptyValue() -> TrustID.Empty
}
public protocol DataDecoder {
  func decode<D>(_ type: D.Type, from data: Foundation.Data) throws -> D where D : Swift.Decodable
}
extension Foundation.JSONDecoder : TrustID.DataDecoder {
}
extension Foundation.PropertyListDecoder : TrustID.DataDecoder {
}
final public class DecodableResponseSerializer<T> : TrustID.ResponseSerializer where T : Swift.Decodable {
  final public let dataPreprocessor: any TrustID.DataPreprocessor
  final public let decoder: any TrustID.DataDecoder
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<TrustID.HTTPMethod>
  public init(dataPreprocessor: any TrustID.DataPreprocessor = DecodableResponseSerializer.defaultDataPreprocessor, decoder: any TrustID.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = DecodableResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> T
  public typealias SerializedObject = T
  @objc deinit
}
extension TrustID.ResponseSerializer {
  public static func decodable<T>(of type: T.Type, dataPreprocessor: any TrustID.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any TrustID.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> TrustID.DecodableResponseSerializer<T> where Self == TrustID.DecodableResponseSerializer<T>, T : Swift.Decodable
}
extension TrustID.DataRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any TrustID.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any TrustID.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (TrustID.AFDataResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
extension TrustID.DownloadRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any TrustID.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any TrustID.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (TrustID.AFDownloadResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
public protocol DataStreamSerializer {
  associatedtype SerializedObject
  func serialize(_ data: Foundation.Data) throws -> Self.SerializedObject
}
public struct DecodableStreamSerializer<T> : TrustID.DataStreamSerializer where T : Swift.Decodable {
  public let decoder: any TrustID.DataDecoder
  public let dataPreprocessor: any TrustID.DataPreprocessor
  public init(decoder: any TrustID.DataDecoder = JSONDecoder(), dataPreprocessor: any TrustID.DataPreprocessor = PassthroughPreprocessor())
  public func serialize(_ data: Foundation.Data) throws -> T
  public typealias SerializedObject = T
}
public struct PassthroughStreamSerializer : TrustID.DataStreamSerializer {
  public init()
  public func serialize(_ data: Foundation.Data) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
}
public struct StringStreamSerializer : TrustID.DataStreamSerializer {
  public init()
  public func serialize(_ data: Foundation.Data) throws -> Swift.String
  public typealias SerializedObject = Swift.String
}
extension TrustID.DataStreamSerializer {
  public static func decodable<T>(of type: T.Type, decoder: any TrustID.DataDecoder = JSONDecoder(), dataPreprocessor: any TrustID.DataPreprocessor = PassthroughPreprocessor()) -> Self where Self == TrustID.DecodableStreamSerializer<T>, T : Swift.Decodable
}
extension TrustID.DataStreamSerializer where Self == TrustID.PassthroughStreamSerializer {
  public static var passthrough: TrustID.PassthroughStreamSerializer {
    get
  }
}
extension TrustID.DataStreamSerializer where Self == TrustID.StringStreamSerializer {
  public static var string: TrustID.StringStreamSerializer {
    get
  }
}
extension TrustID.DataStreamRequest {
  @discardableResult
  final public func responseStream(on queue: Dispatch.DispatchQueue = .main, stream: @escaping TrustID.DataStreamRequest.Handler<Foundation.Data, Swift.Never>) -> Self
  @discardableResult
  final public func responseStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main, stream: @escaping TrustID.DataStreamRequest.Handler<Serializer.SerializedObject, TrustID.AFError>) -> Self where Serializer : TrustID.DataStreamSerializer
  @discardableResult
  final public func responseStreamString(on queue: Dispatch.DispatchQueue = .main, stream: @escaping TrustID.DataStreamRequest.Handler<Swift.String, Swift.Never>) -> Self
  @discardableResult
  final public func responseStreamDecodable<T>(of type: T.Type = T.self, on queue: Dispatch.DispatchQueue = .main, using decoder: any TrustID.DataDecoder = JSONDecoder(), preprocessor: any TrustID.DataPreprocessor = PassthroughPreprocessor(), stream: @escaping TrustID.DataStreamRequest.Handler<T, TrustID.AFError>) -> Self where T : Swift.Decodable
}
open class ServerTrustManager {
  final public let allHostsMustBeEvaluated: Swift.Bool
  final public let evaluators: [Swift.String : any TrustID.ServerTrustEvaluating]
  public init(allHostsMustBeEvaluated: Swift.Bool = true, evaluators: [Swift.String : any TrustID.ServerTrustEvaluating])
  open func serverTrustEvaluator(forHost host: Swift.String) throws -> (any TrustID.ServerTrustEvaluating)?
  @objc deinit
}
public protocol ServerTrustEvaluating {
  func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
final public class DefaultTrustEvaluator : TrustID.ServerTrustEvaluating {
  public init(validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class RevocationTrustEvaluator : TrustID.ServerTrustEvaluating {
  public struct Options : Swift.OptionSet {
    public static let crl: TrustID.RevocationTrustEvaluator.Options
    public static let networkAccessDisabled: TrustID.RevocationTrustEvaluator.Options
    public static let ocsp: TrustID.RevocationTrustEvaluator.Options
    public static let preferCRL: TrustID.RevocationTrustEvaluator.Options
    public static let requirePositiveResponse: TrustID.RevocationTrustEvaluator.Options
    public static let any: TrustID.RevocationTrustEvaluator.Options
    public let rawValue: CoreFoundation.CFOptionFlags
    public init(rawValue: CoreFoundation.CFOptionFlags)
    public typealias ArrayLiteralElement = TrustID.RevocationTrustEvaluator.Options
    public typealias Element = TrustID.RevocationTrustEvaluator.Options
    public typealias RawValue = CoreFoundation.CFOptionFlags
  }
  public init(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: TrustID.RevocationTrustEvaluator.Options = .any)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension TrustID.ServerTrustEvaluating where Self == TrustID.RevocationTrustEvaluator {
  public static var revocationChecking: TrustID.RevocationTrustEvaluator {
    get
  }
  public static func revocationChecking(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: TrustID.RevocationTrustEvaluator.Options = .any) -> TrustID.RevocationTrustEvaluator
}
final public class PinnedCertificatesTrustEvaluator : TrustID.ServerTrustEvaluating {
  public init(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension TrustID.ServerTrustEvaluating where Self == TrustID.PinnedCertificatesTrustEvaluator {
  public static var pinnedCertificates: TrustID.PinnedCertificatesTrustEvaluator {
    get
  }
  public static func pinnedCertificates(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true) -> TrustID.PinnedCertificatesTrustEvaluator
}
final public class PublicKeysTrustEvaluator : TrustID.ServerTrustEvaluating {
  public init(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension TrustID.ServerTrustEvaluating where Self == TrustID.PublicKeysTrustEvaluator {
  public static var publicKeys: TrustID.PublicKeysTrustEvaluator {
    get
  }
  public static func publicKeys(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true) -> TrustID.PublicKeysTrustEvaluator
}
final public class CompositeTrustEvaluator : TrustID.ServerTrustEvaluating {
  public init(evaluators: [any TrustID.ServerTrustEvaluating])
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension TrustID.ServerTrustEvaluating where Self == TrustID.CompositeTrustEvaluator {
  public static func composite(evaluators: [any TrustID.ServerTrustEvaluating]) -> TrustID.CompositeTrustEvaluator
}
@available(*, deprecated, renamed: "DisabledTrustEvaluator", message: "DisabledEvaluator has been renamed DisabledTrustEvaluator.")
public typealias DisabledEvaluator = TrustID.DisabledTrustEvaluator
final public class DisabledTrustEvaluator : TrustID.ServerTrustEvaluating {
  public init()
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension Swift.Array where Element == any TrustID.ServerTrustEvaluating {
  public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
extension Foundation.Bundle : TrustID.AlamofireExtended {
  public typealias ExtendedType = Foundation.Bundle
}
extension TrustID.AlamofireExtension where ExtendedType : Foundation.Bundle {
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
  public func paths(forResourcesOfTypes types: [Swift.String]) -> [Swift.String]
}
extension Security.SecTrust : TrustID.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrust
}
extension TrustID.AlamofireExtension where ExtendedType == Security.SecTrust {
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate(afterApplying policy: Security.SecPolicy) throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate(afterApplying:)")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate(afterApplying:)")
  public func validate(policy: Security.SecPolicy, errorProducer: (_ status: Darwin.OSStatus, _ result: Security.SecTrustResultType) -> any Swift.Error) throws
  public func apply(policy: Security.SecPolicy) throws -> Security.SecTrust
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate() throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate()")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate()")
  public func validate(errorProducer: (_ status: Darwin.OSStatus, _ result: Security.SecTrustResultType) -> any Swift.Error) throws
  public func setAnchorCertificates(_ certificates: [Security.SecCertificate]) throws
  public var publicKeys: [Security.SecKey] {
    get
  }
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var certificateData: [Foundation.Data] {
    get
  }
  public func performDefaultValidation(forHost host: Swift.String) throws
  public func performValidation(forHost host: Swift.String) throws
}
extension Security.SecPolicy : TrustID.AlamofireExtended {
  public typealias ExtendedType = Security.SecPolicy
}
extension TrustID.AlamofireExtension where ExtendedType == Security.SecPolicy {
  public static let `default`: Security.SecPolicy
  public static func hostname(_ hostname: Swift.String) -> Security.SecPolicy
  public static func revocation(options: TrustID.RevocationTrustEvaluator.Options) throws -> Security.SecPolicy
}
extension Swift.Array : TrustID.AlamofireExtended {
  public typealias ExtendedType = Swift.Array<Element>
}
extension TrustID.AlamofireExtension where ExtendedType == [Security.SecCertificate] {
  public var data: [Foundation.Data] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
}
extension Security.SecCertificate : TrustID.AlamofireExtended {
  public typealias ExtendedType = Security.SecCertificate
}
extension TrustID.AlamofireExtension where ExtendedType == Security.SecCertificate {
  public var publicKey: Security.SecKey? {
    get
  }
}
extension Swift.Int32 : TrustID.AlamofireExtended {
  public typealias ExtendedType = Swift.Int32
}
extension TrustID.AlamofireExtension where ExtendedType == Swift.Int32 {
  public var isSuccess: Swift.Bool {
    get
  }
}
extension Security.SecTrustResultType : TrustID.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrustResultType
}
extension TrustID.AlamofireExtension where ExtendedType == Security.SecTrustResultType {
  public var isSuccess: Swift.Bool {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup11 : TrustID.DataGroup {
  public var fullName: Swift.String? {
    get
  }
  public var personalNumber: Swift.String? {
    get
  }
  public var dateOfBirth: Swift.String? {
    get
  }
  public var placeOfBirth: Swift.String? {
    get
  }
  public var address: Swift.String? {
    get
  }
  public var telephone: Swift.String? {
    get
  }
  public var profession: Swift.String? {
    get
  }
  public var title: Swift.String? {
    get
  }
  public var personalSummary: Swift.String? {
    get
  }
  public var proofOfCitizenship: Swift.String? {
    get
  }
  public var tdNumbers: Swift.String? {
    get
  }
  public var custodyInfo: Swift.String? {
    get
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup15 : TrustID.DataGroup {
  public var rsaPublicKey: Swift.OpaquePointer? {
    get
  }
  public var ecdsaPublicKey: Swift.OpaquePointer? {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class DataGroup {
  public var datagroupType: TrustID.DataGroupId
  public var body: [Swift.UInt8] {
    get
  }
  public var data: [Swift.UInt8] {
    get
  }
  public func hash(_ hashAlgorythm: Swift.String) -> [Swift.UInt8]
  @objc deinit
}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
@_Concurrency.MainActor @preconcurrency public struct LottieSwitch {
  @_Concurrency.MainActor @preconcurrency public init(animation: TrustID.LottieAnimation?)
  @_Concurrency.MainActor @preconcurrency public var body: some SwiftUICore.View {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func configure(_ configure: @escaping (TrustID.AnimatedSwitch) -> Swift.Void) -> TrustID.LottieSwitch
  @_Concurrency.MainActor @preconcurrency public func configuration(_ configuration: TrustID.LottieConfiguration) -> TrustID.LottieSwitch
  @_Concurrency.MainActor @preconcurrency public func isOn(_ binding: SwiftUICore.Binding<Swift.Bool>) -> TrustID.LottieSwitch
  @_Concurrency.MainActor @preconcurrency public func onAnimation(fromProgress onStartProgress: TrustID.AnimationProgressTime, toProgress onEndProgress: TrustID.AnimationProgressTime) -> TrustID.LottieSwitch
  @_Concurrency.MainActor @preconcurrency public func offAnimation(fromProgress offStartProgress: TrustID.AnimationProgressTime, toProgress offEndProgress: TrustID.AnimationProgressTime) -> TrustID.LottieSwitch
  @_Concurrency.MainActor @preconcurrency public func valueProvider<ValueProvider>(_ valueProvider: ValueProvider, for keypath: TrustID.AnimationKeypath) -> TrustID.LottieSwitch where ValueProvider : Swift.Equatable, ValueProvider : TrustID.AnyValueProvider
  @available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
  public typealias Body = @_opaqueReturnTypeOf("$s7TrustID12LottieSwitchV4bodyQrvp", 0) __
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class AnimatedButton : TrustID.AnimatedControl {
  @_Concurrency.MainActor @preconcurrency override public init(animation: TrustID.LottieAnimation?, configuration: TrustID.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor @preconcurrency public var performAction: (() -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var accessibilityTraits: UIKit.UIAccessibilityTraits {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency public func setPlayRange(fromProgress: TrustID.AnimationProgressTime, toProgress: TrustID.AnimationProgressTime, event: TrustID.LottieControlEvent)
  @_Concurrency.MainActor @preconcurrency public func setPlayRange(fromMarker fromName: Swift.String, toMarker toName: Swift.String, event: TrustID.LottieControlEvent)
  @objc deinit
}
public enum RenderingEngineOption : Swift.Hashable {
  case automatic
  case specific(TrustID.RenderingEngine)
  public static var mainThread: TrustID.RenderingEngineOption {
    get
  }
  public static var coreAnimation: TrustID.RenderingEngineOption {
    get
  }
}
public enum RenderingEngine : Swift.Hashable {
  case mainThread
  case coreAnimation
}
extension TrustID.RenderingEngineOption : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension TrustID.RenderingEngine : Swift.RawRepresentable, Swift.CustomStringConvertible {
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
  public typealias RawValue = Swift.String
}
extension TrustID.LottieVector1D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct LottieVector2D : Swift.Codable, Swift.Hashable, Swift.Sendable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TrustID.LottieVector2D, b: TrustID.LottieVector2D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension TrustID.LottieVector3D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension TrustID.LottieVector3D {
  public var pointValue: CoreFoundation.CGPoint {
    get
  }
  public var sizeValue: CoreFoundation.CGSize {
    get
  }
}
public struct AnimationKeypath : Swift.Hashable, Swift.ExpressibleByStringLiteral {
  public init(keypath: Swift.String)
  public init(stringLiteral: Swift.String)
  public init(keys: [Swift.String])
  public var keys: [Swift.String] {
    get
  }
  public var string: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TrustID.AnimationKeypath, b: TrustID.AnimationKeypath) -> Swift.Bool
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
public struct LottieConfiguration : Swift.Hashable {
  public init(renderingEngine: TrustID.RenderingEngineOption = .automatic, decodingStrategy: TrustID.DecodingStrategy = .dictionaryBased, colorSpace: CoreGraphics.CGColorSpace = CGColorSpaceCreateDeviceRGB(), reducedMotionOption: TrustID.ReducedMotionOption = .systemReducedMotionToggle)
  public static var shared: TrustID.LottieConfiguration
  public var renderingEngine: TrustID.RenderingEngineOption
  public var decodingStrategy: TrustID.DecodingStrategy
  public var reducedMotionOption: TrustID.ReducedMotionOption
  public var colorSpace: CoreGraphics.CGColorSpace
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TrustID.LottieConfiguration, b: TrustID.LottieConfiguration) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum AFError : Swift.Error {
  public enum MultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: any Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: any Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: any Swift.Error)
    case inputStreamReadFailed(error: any Swift.Error)
  }
  public struct UnexpectedInputStreamLength : Swift.Error {
    public var bytesExpected: Swift.UInt64
    public var bytesRead: Swift.UInt64
  }
  public enum ParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: any Swift.Error)
    case customEncodingFailed(error: any Swift.Error)
  }
  public enum ParameterEncoderFailureReason {
    public enum RequiredComponent {
      case url
      case httpMethod(rawValue: Swift.String)
    }
    case missingRequiredComponent(TrustID.AFError.ParameterEncoderFailureReason.RequiredComponent)
    case encoderFailed(error: any Swift.Error)
  }
  public enum ResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
    case customValidationFailed(error: any Swift.Error)
  }
  public enum ResponseSerializationFailureReason {
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: any Swift.Error)
    case decodingFailed(error: any Swift.Error)
    case customSerializationFailed(error: any Swift.Error)
    case invalidEmptyResponse(type: Swift.String)
  }
  public enum ServerTrustFailureReason {
    public struct Output {
      public let host: Swift.String
      public let trust: Security.SecTrust
      public let status: Darwin.OSStatus
      public let result: Security.SecTrustResultType
    }
    case noRequiredEvaluator(host: Swift.String)
    case noCertificatesFound
    case noPublicKeysFound
    case policyApplicationFailed(trust: Security.SecTrust, policy: Security.SecPolicy, status: Darwin.OSStatus)
    case settingAnchorCertificatesFailed(status: Darwin.OSStatus, certificates: [Security.SecCertificate])
    case revocationPolicyCreationFailed
    case trustEvaluationFailed(error: (any Swift.Error)?)
    case defaultEvaluationFailed(output: TrustID.AFError.ServerTrustFailureReason.Output)
    case hostValidationFailed(output: TrustID.AFError.ServerTrustFailureReason.Output)
    case revocationCheckFailed(output: TrustID.AFError.ServerTrustFailureReason.Output, options: TrustID.RevocationTrustEvaluator.Options)
    case certificatePinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedCertificates: [Security.SecCertificate], serverCertificates: [Security.SecCertificate])
    case publicKeyPinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedKeys: [Security.SecKey], serverKeys: [Security.SecKey])
    case customEvaluationFailed(error: any Swift.Error)
  }
  public enum URLRequestValidationFailureReason {
    case bodyDataInGETRequest(Foundation.Data)
  }
  case createUploadableFailed(error: any Swift.Error)
  case createURLRequestFailed(error: any Swift.Error)
  case downloadedFileMoveFailed(error: any Swift.Error, source: Foundation.URL, destination: Foundation.URL)
  case explicitlyCancelled
  case invalidURL(url: any TrustID.URLConvertible)
  case multipartEncodingFailed(reason: TrustID.AFError.MultipartEncodingFailureReason)
  case parameterEncodingFailed(reason: TrustID.AFError.ParameterEncodingFailureReason)
  case parameterEncoderFailed(reason: TrustID.AFError.ParameterEncoderFailureReason)
  case requestAdaptationFailed(error: any Swift.Error)
  case requestRetryFailed(retryError: any Swift.Error, originalError: any Swift.Error)
  case responseValidationFailed(reason: TrustID.AFError.ResponseValidationFailureReason)
  case responseSerializationFailed(reason: TrustID.AFError.ResponseSerializationFailureReason)
  case serverTrustEvaluationFailed(reason: TrustID.AFError.ServerTrustFailureReason)
  case sessionDeinitialized
  case sessionInvalidated(error: (any Swift.Error)?)
  case sessionTaskFailed(error: any Swift.Error)
  case urlRequestValidationFailed(reason: TrustID.AFError.URLRequestValidationFailureReason)
}
extension Swift.Error {
  public var asAFError: TrustID.AFError? {
    get
  }
  public func asAFError(orFailWith message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> TrustID.AFError
}
extension TrustID.AFError {
  public var isSessionDeinitializedError: Swift.Bool {
    get
  }
  public var isSessionInvalidatedError: Swift.Bool {
    get
  }
  public var isExplicitlyCancelledError: Swift.Bool {
    get
  }
  public var isInvalidURLError: Swift.Bool {
    get
  }
  public var isParameterEncodingError: Swift.Bool {
    get
  }
  public var isParameterEncoderError: Swift.Bool {
    get
  }
  public var isMultipartEncodingError: Swift.Bool {
    get
  }
  public var isRequestAdaptationError: Swift.Bool {
    get
  }
  public var isResponseValidationError: Swift.Bool {
    get
  }
  public var isResponseSerializationError: Swift.Bool {
    get
  }
  public var isServerTrustEvaluationError: Swift.Bool {
    get
  }
  public var isRequestRetryError: Swift.Bool {
    get
  }
  public var isCreateUploadableError: Swift.Bool {
    get
  }
  public var isCreateURLRequestError: Swift.Bool {
    get
  }
  public var isDownloadedFileMoveError: Swift.Bool {
    get
  }
  public var isSessionTaskError: Swift.Bool {
    get
  }
}
extension TrustID.AFError {
  public var urlConvertible: (any TrustID.URLConvertible)? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var underlyingError: (any Swift.Error)? {
    get
  }
  public var acceptableContentTypes: [Swift.String]? {
    get
  }
  public var responseContentType: Swift.String? {
    get
  }
  public var responseCode: Swift.Int? {
    get
  }
  public var failedStringEncoding: Swift.String.Encoding? {
    get
  }
  public var sourceURL: Foundation.URL? {
    get
  }
  public var destinationURL: Foundation.URL? {
    get
  }
  public var downloadResumeData: Foundation.Data? {
    get
  }
}
extension TrustID.AFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@available(iOS 13.0, tvOS 13.0, *)
@_Concurrency.MainActor @preconcurrency open class EpoxySwiftUIHostingController<Content> : SwiftUI.UIHostingController<Content> where Content : SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor @preconcurrency override public init(rootView: Content)
  @_Concurrency.MainActor @preconcurrency override public init?(coder aDecoder: Foundation.NSCoder, rootView: Content)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
final public class GradientValueProvider {
  public init(block: @escaping TrustID.GradientValueProvider.ColorsValueBlock, locations: TrustID.GradientValueProvider.ColorLocationsBlock? = nil)
  public init(_ colors: [TrustID.LottieColor], locations: [Swift.Double] = [])
  public typealias ColorsValueBlock = (CoreFoundation.CGFloat) -> [TrustID.LottieColor]
  public typealias ColorLocationsBlock = (CoreFoundation.CGFloat) -> [Swift.Double]
  final public var colors: [TrustID.LottieColor] {
    get
    set
  }
  final public var locations: [Swift.Double] {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: TrustID.ValueProviderStorage<[Swift.Double]> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension TrustID.GradientValueProvider : Swift.Equatable {
  public static func == (lhs: TrustID.GradientValueProvider, rhs: TrustID.GradientValueProvider) -> Swift.Bool
}
@objc public enum TrustIdPresentationStyle : Swift.Int {
  case Full = 0
  case Sheet
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public let AF: TrustID.Session
@objc final public class CompatibleAnimationKeypath : ObjectiveC.NSObject {
  @objc public init(keypath: Swift.String)
  @objc public init(keys: [Swift.String])
  final public let animationKeypath: TrustID.AnimationKeypath
  @objc deinit
}
open class RetryPolicy : TrustID.RequestInterceptor {
  public static let defaultRetryLimit: Swift.UInt
  public static let defaultExponentialBackoffBase: Swift.UInt
  public static let defaultExponentialBackoffScale: Swift.Double
  public static let defaultRetryableHTTPMethods: Swift.Set<TrustID.HTTPMethod>
  public static let defaultRetryableHTTPStatusCodes: Swift.Set<Swift.Int>
  public static let defaultRetryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  final public let retryLimit: Swift.UInt
  final public let exponentialBackoffBase: Swift.UInt
  final public let exponentialBackoffScale: Swift.Double
  final public let retryableHTTPMethods: Swift.Set<TrustID.HTTPMethod>
  final public let retryableHTTPStatusCodes: Swift.Set<Swift.Int>
  final public let retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<TrustID.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes)
  open func retry(_ request: TrustID.Request, for session: TrustID.Session, dueTo error: any Swift.Error, completion: @escaping (TrustID.RetryResult) -> Swift.Void)
  open func shouldRetry(request: TrustID.Request, dueTo error: any Swift.Error) -> Swift.Bool
  @objc deinit
}
extension TrustID.RequestInterceptor where Self == TrustID.RetryPolicy {
  public static var retryPolicy: TrustID.RetryPolicy {
    get
  }
  public static func retryPolicy(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<TrustID.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes) -> TrustID.RetryPolicy
}
open class ConnectionLostRetryPolicy : TrustID.RetryPolicy {
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<TrustID.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods)
  @objc deinit
}
extension TrustID.RequestInterceptor where Self == TrustID.ConnectionLostRetryPolicy {
  public static var connectionLostRetryPolicy: TrustID.ConnectionLostRetryPolicy {
    get
  }
  public static func connectionLostRetryPolicy(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<TrustID.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods) -> TrustID.ConnectionLostRetryPolicy
}
@_inheritsConvenienceInitializers @objc public class TrustIdAppearance : ObjectiveC.NSObject {
  @objc public var logo: UIKit.UIImage?
  @objc public var colorPrimary: UIKit.UIColor?
  @objc public var colorBackground: UIKit.UIColor?
  @objc public var colorForeground: UIKit.UIColor?
  @objc override dynamic public init()
  @objc deinit
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension TrustID.Request {
  public func uploadProgress(bufferingPolicy: TrustID.StreamOf<Foundation.Progress>.BufferingPolicy = .unbounded) -> TrustID.StreamOf<Foundation.Progress>
  public func downloadProgress(bufferingPolicy: TrustID.StreamOf<Foundation.Progress>.BufferingPolicy = .unbounded) -> TrustID.StreamOf<Foundation.Progress>
  public func urlRequests(bufferingPolicy: TrustID.StreamOf<Foundation.URLRequest>.BufferingPolicy = .unbounded) -> TrustID.StreamOf<Foundation.URLRequest>
  public func urlSessionTasks(bufferingPolicy: TrustID.StreamOf<Foundation.URLSessionTask>.BufferingPolicy = .unbounded) -> TrustID.StreamOf<Foundation.URLSessionTask>
  public func cURLDescriptions(bufferingPolicy: TrustID.StreamOf<Swift.String>.BufferingPolicy = .unbounded) -> TrustID.StreamOf<Swift.String>
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DataTask<Value> {
  public var response: TrustID.DataResponse<Value, TrustID.AFError> {
    get async
  }
  public var result: Swift.Result<Value, TrustID.AFError> {
    get async
  }
  public var value: Value {
    get async throws
  }
  public func cancel()
  public func resume()
  public func suspend()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension TrustID.DataRequest {
  public func httpResponses(bufferingPolicy: TrustID.StreamOf<Foundation.HTTPURLResponse>.BufferingPolicy = .unbounded) -> TrustID.StreamOf<Foundation.HTTPURLResponse>
  @discardableResult
  @_disfavoredOverload public func onHTTPResponse(perform handler: @escaping @Sendable (_ response: Foundation.HTTPURLResponse) async -> TrustID.Request.ResponseDisposition) -> Self
  @discardableResult
  public func onHTTPResponse(perform handler: @escaping @Sendable (_ response: Foundation.HTTPURLResponse) async -> Swift.Void) -> Self
  public func serializingData(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, dataPreprocessor: any TrustID.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> TrustID.DataTask<Foundation.Data>
  public func serializingDecodable<Value>(_ type: Value.Type = Value.self, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, dataPreprocessor: any TrustID.DataPreprocessor = DecodableResponseSerializer<Value>.defaultDataPreprocessor, decoder: any TrustID.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<Value>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = DecodableResponseSerializer<Value>.defaultEmptyRequestMethods) -> TrustID.DataTask<Value> where Value : Swift.Decodable
  public func serializingString(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, dataPreprocessor: any TrustID.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> TrustID.DataTask<Swift.String>
  public func serializingResponse<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true) -> TrustID.DataTask<Serializer.SerializedObject> where Serializer : TrustID.ResponseSerializer
  public func serializingResponse<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true) -> TrustID.DataTask<Serializer.SerializedObject> where Serializer : TrustID.DataResponseSerializerProtocol
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DownloadTask<Value> {
  public var response: TrustID.DownloadResponse<Value, TrustID.AFError> {
    get async
  }
  public var result: Swift.Result<Value, TrustID.AFError> {
    get async
  }
  public var value: Value {
    get async throws
  }
  public func cancel()
  public func resume()
  public func suspend()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension TrustID.DownloadRequest {
  public func serializingData(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, dataPreprocessor: any TrustID.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> TrustID.DownloadTask<Foundation.Data>
  public func serializingDecodable<Value>(_ type: Value.Type = Value.self, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, dataPreprocessor: any TrustID.DataPreprocessor = DecodableResponseSerializer<Value>.defaultDataPreprocessor, decoder: any TrustID.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<Value>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = DecodableResponseSerializer<Value>.defaultEmptyRequestMethods) -> TrustID.DownloadTask<Value> where Value : Swift.Decodable
  public func serializingDownloadedFileURL(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true) -> TrustID.DownloadTask<Foundation.URL>
  public func serializingString(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, dataPreprocessor: any TrustID.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<TrustID.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> TrustID.DownloadTask<Swift.String>
  public func serializingDownload<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true) -> TrustID.DownloadTask<Serializer.SerializedObject> where Serializer : TrustID.ResponseSerializer
  public func serializingDownload<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true) -> TrustID.DownloadTask<Serializer.SerializedObject> where Serializer : TrustID.DownloadResponseSerializerProtocol
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DataStreamTask {
  public typealias Stream<Success, Failure> = TrustID.StreamOf<TrustID.DataStreamRequest.Stream<Success, Failure>> where Failure : Swift.Error
  public func streamingData(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: TrustID.DataStreamTask.Stream<Foundation.Data, Swift.Never>.BufferingPolicy = .unbounded) -> TrustID.DataStreamTask.Stream<Foundation.Data, Swift.Never>
  public func streamingStrings(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: TrustID.DataStreamTask.Stream<Swift.String, Swift.Never>.BufferingPolicy = .unbounded) -> TrustID.DataStreamTask.Stream<Swift.String, Swift.Never>
  public func streamingDecodables<T>(_ type: T.Type = T.self, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: TrustID.DataStreamTask.Stream<T, TrustID.AFError>.BufferingPolicy = .unbounded) -> TrustID.DataStreamTask.Stream<T, TrustID.AFError> where T : Swift.Decodable
  public func streamingResponses<Serializer>(serializedUsing serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: TrustID.DataStreamTask.Stream<Serializer.SerializedObject, TrustID.AFError>.BufferingPolicy = .unbounded) -> TrustID.DataStreamTask.Stream<Serializer.SerializedObject, TrustID.AFError> where Serializer : TrustID.DataStreamSerializer
  public func cancel()
  public func resume()
  public func suspend()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension TrustID.DataStreamRequest {
  final public func httpResponses(bufferingPolicy: TrustID.StreamOf<Foundation.HTTPURLResponse>.BufferingPolicy = .unbounded) -> TrustID.StreamOf<Foundation.HTTPURLResponse>
  @discardableResult
  @_disfavoredOverload final public func onHTTPResponse(perform handler: @escaping @Sendable (Foundation.HTTPURLResponse) async -> TrustID.Request.ResponseDisposition) -> Self
  @discardableResult
  final public func onHTTPResponse(perform handler: @escaping @Sendable (Foundation.HTTPURLResponse) async -> Swift.Void) -> Self
  final public func streamTask() -> TrustID.DataStreamTask
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct StreamOf<Element> : _Concurrency.AsyncSequence {
  public typealias AsyncIterator = TrustID.StreamOf<Element>.Iterator
  public typealias BufferingPolicy = _Concurrency.AsyncStream<Element>.Continuation.BufferingPolicy
  public func makeAsyncIterator() -> TrustID.StreamOf<Element>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    public mutating func next() async -> Element?
    #if compiler(>=5.3) && $AssociatedTypeImplements
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    @_implements(_Concurrency.AsyncIteratorProtocol, Failure) public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    #else
    @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
    public typealias __AsyncIteratorProtocol_Failure = Swift.Never
    #endif
  }
  #if compiler(>=5.3) && $AssociatedTypeImplements
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  @_implements(_Concurrency.AsyncSequence, Failure) public typealias __AsyncSequence_Failure = Swift.Never
  #else
  @available(iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, macOS 15.0, *)
  public typealias __AsyncSequence_Failure = Swift.Never
  #endif
}
public enum LottieAnimationSource : Swift.Sendable {
  case lottieAnimation(TrustID.LottieAnimation)
  case dotLottieFile(TrustID.DotLottieFile)
}
extension TrustID.LottieAnimation {
  final public var animationSource: TrustID.LottieAnimationSource {
    get
  }
}
extension TrustID.DotLottieFile {
  final public var animationSource: TrustID.LottieAnimationSource {
    get
  }
}
public typealias LottieCompletionBlock = (_ completed: Swift.Bool) -> Swift.Void
public typealias LottieControlType = UIKit.UIControl
public typealias LottieControlState = UIKit.UIControl.State
public typealias LottieControlEvent = UIKit.UIControl.Event
@objc @available(iOS 13, *)
public class PassportReader : ObjectiveC.NSObject {
  public var passiveAuthenticationUsesOpenSSL: Swift.Bool
  public init(logLevel: TrustID.LogLevel = .info, masterListURL: Foundation.URL? = nil)
  public func setMasterListURL(_ masterListURL: Foundation.URL)
  public func overrideNFCDataAmountToRead(amount: Swift.Int)
  public func readPassport(mrzKey: Swift.String, tags: [TrustID.DataGroupId] = [], skipSecureElements: Swift.Bool = true, skipCA: Swift.Bool = false, skipPACE: Swift.Bool = false, customDisplayMessage: ((TrustID.NFCViewDisplayMessage) -> Swift.String?)? = nil, completed: @escaping (TrustID.NFCPassportModel?, TrustID.NFCPassportReaderError?) -> ())
  @objc deinit
}
@available(iOS 13, *)
extension TrustID.PassportReader : CoreNFC.NFCTagReaderSessionDelegate {
  public func tagReaderSessionDidBecomeActive(_ session: CoreNFC.NFCTagReaderSession)
  public func tagReaderSession(_ session: CoreNFC.NFCTagReaderSession, didInvalidateWithError error: any Swift.Error)
  public func tagReaderSession(_ session: CoreNFC.NFCTagReaderSession, didDetect tags: [CoreNFC.NFCTag])
}
public func binToHexRep(_ val: [Swift.UInt8], asArray: Swift.Bool = false) -> Swift.String
public func binToHexRep(_ val: Swift.UInt8) -> Swift.String
public func binToHex(_ val: Swift.UInt8) -> Swift.Int
public func binToHex(_ val: [Swift.UInt8]) -> Swift.UInt64
public func binToHex(_ val: Swift.ArraySlice<Swift.UInt8>) -> Swift.UInt64
public func hexToBin(_ val: Swift.UInt64) -> [Swift.UInt8]
public func binToInt(_ val: Swift.ArraySlice<Swift.UInt8>) -> Swift.Int
public func binToInt(_ val: [Swift.UInt8]) -> Swift.Int
public func intToBin(_ data: Swift.Int, pad: Swift.Int = 2) -> [Swift.UInt8]
public func hexRepToBin(_ val: Swift.String) -> [Swift.UInt8]
public func xor(_ kifd: [Swift.UInt8], _ response_kicc: [Swift.UInt8]) -> [Swift.UInt8]
public func generateRandomUInt8Array(_ size: Swift.Int) -> [Swift.UInt8]
public func pad(_ toPad: [Swift.UInt8], blockSize: Swift.Int) -> [Swift.UInt8]
public func unpad(_ tounpad: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func mac(algoName: TrustID.SecureMessagingSupportedAlgorithms, key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func desMAC(key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func aesMAC(key: [Swift.UInt8], msg: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func wrapDO(b: Swift.UInt8, arr: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func unwrapDO(tag: Swift.UInt8, wrappedData: [Swift.UInt8]) throws -> [Swift.UInt8]
public func intToBytes(val: Swift.Int, removePadding: Swift.Bool) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func oidToBytes(oid: Swift.String, replaceTag: Swift.Bool) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func asn1Length(_ data: Swift.ArraySlice<Swift.UInt8>) throws -> (Swift.Int, Swift.Int)
@available(iOS 13, macOS 10.15, *)
public func asn1Length(_ data: [Swift.UInt8]) throws -> (Swift.Int, Swift.Int)
@available(iOS 13, macOS 10.15, *)
public func toAsn1Length(_ data: Swift.Int) throws -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcHash(data: [Swift.UInt8], hashAlgorithm: Swift.String) throws -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA1Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA224Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA256Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA512Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@available(iOS 13, macOS 10.15, *)
public func calcSHA384Hash(_ data: [Swift.UInt8]) -> [Swift.UInt8]
@_inheritsConvenienceInitializers @objc public class TrustIdAction : ObjectiveC.NSObject {
  @_inheritsConvenienceInitializers @objc public class Complete : TrustID.TrustIdAction {
    @objc public var result: TrustID.TrustIdResult
    @objc override dynamic public init()
    @objc deinit
  }
  @_inheritsConvenienceInitializers @objc public class Error : TrustID.TrustIdAction {
    @objc public var exception: TrustID.TrustIdException
    @objc override dynamic public init()
    @objc deinit
  }
  @_inheritsConvenienceInitializers @objc public class Permission : TrustID.TrustIdAction {
    @objc override dynamic public init()
    @objc deinit
  }
  @_inheritsConvenienceInitializers @objc public class Timeout : TrustID.TrustIdAction {
    @objc override dynamic public init()
    @objc deinit
  }
  @_inheritsConvenienceInitializers @objc public class Cancel : TrustID.TrustIdAction {
    @objc override dynamic public init()
    @objc deinit
  }
  @objc override dynamic public init()
  @objc deinit
}
final public class LottieLogger {
  public init(assert: @escaping TrustID.LottieLogger.Assert = { condition, message, file, line in
       
       
       
      Swift.assert(condition(), message(), file: file, line: line)
    }, assertionFailure: @escaping TrustID.LottieLogger.AssertionFailure = { message, file, line in
       
       
       
       
      Swift.assertionFailure(message(), file: file, line: line)
    }, warn: @escaping TrustID.LottieLogger.Warn = { message, _, _ in
    }, info: @escaping TrustID.LottieLogger.Info = { message in
    })
  public typealias Assert = (_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias AssertionFailure = (_ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias Warn = (_ message: @autoclosure () -> Swift.String, _ fileID: Swift.StaticString, _ line: Swift.UInt) -> Swift.Void
  public typealias Info = (_ message: @autoclosure () -> Swift.String) -> Swift.Void
  public static var shared: TrustID.LottieLogger
  final public func assert(_ condition: @autoclosure () -> Swift.Bool, _ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func assertionFailure(_ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func warn(_ message: @autoclosure () -> Swift.String = String(), fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func info(_ message: @autoclosure () -> Swift.String = String())
  @objc deinit
}
extension TrustID.LottieLogger {
  public static var printToConsole: TrustID.LottieLogger {
    get
  }
}
open class Session {
  public static let `default`: TrustID.Session
  final public let session: Foundation.URLSession
  final public let delegate: TrustID.SessionDelegate
  final public let rootQueue: Dispatch.DispatchQueue
  final public let startRequestsImmediately: Swift.Bool
  final public let requestQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let interceptor: (any TrustID.RequestInterceptor)?
  final public let serverTrustManager: TrustID.ServerTrustManager?
  final public let redirectHandler: (any TrustID.RedirectHandler)?
  final public let cachedResponseHandler: (any TrustID.CachedResponseHandler)?
  final public let eventMonitor: TrustID.CompositeEventMonitor
  final public let defaultEventMonitors: [any TrustID.EventMonitor]
  public init(session: Foundation.URLSession, delegate: TrustID.SessionDelegate, rootQueue: Dispatch.DispatchQueue, startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: (any TrustID.RequestInterceptor)? = nil, serverTrustManager: TrustID.ServerTrustManager? = nil, redirectHandler: (any TrustID.RedirectHandler)? = nil, cachedResponseHandler: (any TrustID.CachedResponseHandler)? = nil, eventMonitors: [any TrustID.EventMonitor] = [])
  convenience public init(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.af.default, delegate: TrustID.SessionDelegate = SessionDelegate(), rootQueue: Dispatch.DispatchQueue = DispatchQueue(label: "org.alamofire.session.rootQueue"), startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: (any TrustID.RequestInterceptor)? = nil, serverTrustManager: TrustID.ServerTrustManager? = nil, redirectHandler: (any TrustID.RedirectHandler)? = nil, cachedResponseHandler: (any TrustID.CachedResponseHandler)? = nil, eventMonitors: [any TrustID.EventMonitor] = [])
  @objc deinit
  public func withAllRequests(perform action: @escaping (Swift.Set<TrustID.Request>) -> Swift.Void)
  public func cancelAllRequests(completingOnQueue queue: Dispatch.DispatchQueue = .main, completion: (() -> Swift.Void)? = nil)
  public typealias RequestModifier = (inout Foundation.URLRequest) throws -> Swift.Void
  open func request(_ convertible: any TrustID.URLConvertible, method: TrustID.HTTPMethod = .get, parameters: TrustID.Parameters? = nil, encoding: any TrustID.ParameterEncoding = URLEncoding.default, headers: TrustID.HTTPHeaders? = nil, interceptor: (any TrustID.RequestInterceptor)? = nil, requestModifier: TrustID.Session.RequestModifier? = nil) -> TrustID.DataRequest
  open func request<Parameters>(_ convertible: any TrustID.URLConvertible, method: TrustID.HTTPMethod = .get, parameters: Parameters? = nil, encoder: any TrustID.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: TrustID.HTTPHeaders? = nil, interceptor: (any TrustID.RequestInterceptor)? = nil, requestModifier: TrustID.Session.RequestModifier? = nil) -> TrustID.DataRequest where Parameters : Swift.Encodable
  open func request(_ convertible: any TrustID.URLRequestConvertible, interceptor: (any TrustID.RequestInterceptor)? = nil) -> TrustID.DataRequest
  open func streamRequest<Parameters>(_ convertible: any TrustID.URLConvertible, method: TrustID.HTTPMethod = .get, parameters: Parameters? = nil, encoder: any TrustID.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: TrustID.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: (any TrustID.RequestInterceptor)? = nil, requestModifier: TrustID.Session.RequestModifier? = nil) -> TrustID.DataStreamRequest where Parameters : Swift.Encodable
  open func streamRequest(_ convertible: any TrustID.URLConvertible, method: TrustID.HTTPMethod = .get, headers: TrustID.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: (any TrustID.RequestInterceptor)? = nil, requestModifier: TrustID.Session.RequestModifier? = nil) -> TrustID.DataStreamRequest
  open func streamRequest(_ convertible: any TrustID.URLRequestConvertible, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: (any TrustID.RequestInterceptor)? = nil) -> TrustID.DataStreamRequest
  open func download(_ convertible: any TrustID.URLConvertible, method: TrustID.HTTPMethod = .get, parameters: TrustID.Parameters? = nil, encoding: any TrustID.ParameterEncoding = URLEncoding.default, headers: TrustID.HTTPHeaders? = nil, interceptor: (any TrustID.RequestInterceptor)? = nil, requestModifier: TrustID.Session.RequestModifier? = nil, to destination: TrustID.DownloadRequest.Destination? = nil) -> TrustID.DownloadRequest
  open func download<Parameters>(_ convertible: any TrustID.URLConvertible, method: TrustID.HTTPMethod = .get, parameters: Parameters? = nil, encoder: any TrustID.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: TrustID.HTTPHeaders? = nil, interceptor: (any TrustID.RequestInterceptor)? = nil, requestModifier: TrustID.Session.RequestModifier? = nil, to destination: TrustID.DownloadRequest.Destination? = nil) -> TrustID.DownloadRequest where Parameters : Swift.Encodable
  open func download(_ convertible: any TrustID.URLRequestConvertible, interceptor: (any TrustID.RequestInterceptor)? = nil, to destination: TrustID.DownloadRequest.Destination? = nil) -> TrustID.DownloadRequest
  open func download(resumingWith data: Foundation.Data, interceptor: (any TrustID.RequestInterceptor)? = nil, to destination: TrustID.DownloadRequest.Destination? = nil) -> TrustID.DownloadRequest
  open func upload(_ data: Foundation.Data, to convertible: any TrustID.URLConvertible, method: TrustID.HTTPMethod = .post, headers: TrustID.HTTPHeaders? = nil, interceptor: (any TrustID.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: TrustID.Session.RequestModifier? = nil) -> TrustID.UploadRequest
  open func upload(_ data: Foundation.Data, with convertible: any TrustID.URLRequestConvertible, interceptor: (any TrustID.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> TrustID.UploadRequest
  open func upload(_ fileURL: Foundation.URL, to convertible: any TrustID.URLConvertible, method: TrustID.HTTPMethod = .post, headers: TrustID.HTTPHeaders? = nil, interceptor: (any TrustID.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: TrustID.Session.RequestModifier? = nil) -> TrustID.UploadRequest
  open func upload(_ fileURL: Foundation.URL, with convertible: any TrustID.URLRequestConvertible, interceptor: (any TrustID.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> TrustID.UploadRequest
  open func upload(_ stream: Foundation.InputStream, to convertible: any TrustID.URLConvertible, method: TrustID.HTTPMethod = .post, headers: TrustID.HTTPHeaders? = nil, interceptor: (any TrustID.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: TrustID.Session.RequestModifier? = nil) -> TrustID.UploadRequest
  open func upload(_ stream: Foundation.InputStream, with convertible: any TrustID.URLRequestConvertible, interceptor: (any TrustID.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> TrustID.UploadRequest
  open func upload(multipartFormData: @escaping (TrustID.MultipartFormData) -> Swift.Void, to url: any TrustID.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, method: TrustID.HTTPMethod = .post, headers: TrustID.HTTPHeaders? = nil, interceptor: (any TrustID.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: TrustID.Session.RequestModifier? = nil) -> TrustID.UploadRequest
  open func upload(multipartFormData: @escaping (TrustID.MultipartFormData) -> Swift.Void, with request: any TrustID.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, interceptor: (any TrustID.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> TrustID.UploadRequest
  open func upload(multipartFormData: TrustID.MultipartFormData, to url: any TrustID.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, method: TrustID.HTTPMethod = .post, headers: TrustID.HTTPHeaders? = nil, interceptor: (any TrustID.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: TrustID.Session.RequestModifier? = nil) -> TrustID.UploadRequest
  open func upload(multipartFormData: TrustID.MultipartFormData, with request: any TrustID.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, interceptor: (any TrustID.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> TrustID.UploadRequest
}
extension TrustID.Session : TrustID.RequestDelegate {
  public var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
  }
  public var startImmediately: Swift.Bool {
    get
  }
  public func cleanup(after request: TrustID.Request)
  public func retryResult(for request: TrustID.Request, dueTo error: TrustID.AFError, completion: @escaping (TrustID.RetryResult) -> Swift.Void)
  public func retryRequest(_ request: TrustID.Request, withDelay timeDelay: Foundation.TimeInterval?)
}
public protocol AnimationImageProvider {
  var cacheEligible: Swift.Bool { get }
  func imageForAsset(asset: TrustID.ImageAsset) -> CoreGraphics.CGImage?
  func contentsGravity(for asset: TrustID.ImageAsset) -> QuartzCore.CALayerContentsGravity
}
extension TrustID.AnimationImageProvider {
  public var cacheEligible: Swift.Bool {
    get
  }
  public func contentsGravity(for _: TrustID.ImageAsset) -> QuartzCore.CALayerContentsGravity
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class AnimatedSwitch : TrustID.AnimatedControl {
  @_Concurrency.MainActor @preconcurrency override public init(animation: TrustID.LottieAnimation?, configuration: TrustID.LottieConfiguration = .shared)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init()
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor @preconcurrency override open func animationDidSet()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  public enum CancelBehavior {
    case reverse
    case none
    public static func == (a: TrustID.AnimatedSwitch.CancelBehavior, b: TrustID.AnimatedSwitch.CancelBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor @preconcurrency public var cancelBehavior: TrustID.AnimatedSwitch.CancelBehavior
  @_Concurrency.MainActor @preconcurrency public var animateUpdateWhenChangingAnimation: Swift.Bool
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var accessibilityTraits: UIKit.UIAccessibilityTraits {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency public var stateUpdated: ((_ isOn: Swift.Bool) -> Swift.Void)?
  @_Concurrency.MainActor @preconcurrency public var isOn: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor @preconcurrency public func setIsOn(_ isOn: Swift.Bool, animated: Swift.Bool, shouldFireHaptics: Swift.Bool = true)
  @_Concurrency.MainActor @preconcurrency public func setProgressForState(fromProgress: TrustID.AnimationProgressTime, toProgress: TrustID.AnimationProgressTime, forOnState: Swift.Bool)
  @objc deinit
}
@objc public enum TrustIdEnvironment : Swift.Int {
  case Production = 0
  case Development
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
open class MultipartFormData {
  public static let encodingMemoryThreshold: Swift.UInt64
  open var contentType: Swift.String {
    get
    set
  }
  public var contentLength: Swift.UInt64 {
    get
  }
  final public let boundary: Swift.String
  public init(fileManager: Foundation.FileManager = .default, boundary: Swift.String? = nil)
  public func append(_ data: Foundation.Data, withName name: Swift.String, fileName: Swift.String? = nil, mimeType: Swift.String? = nil)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, headers: TrustID.HTTPHeaders)
  public func encode() throws -> Foundation.Data
  public func writeEncodedData(to fileURL: Foundation.URL) throws
  @objc deinit
}
@available(iOS 13, macOS 10.15, *)
public enum DataGroupId : Swift.Int, Swift.CaseIterable {
  case COM
  case DG1
  case DG2
  case DG3
  case DG4
  case DG5
  case DG6
  case DG7
  case DG8
  case DG9
  case DG10
  case DG11
  case DG12
  case DG13
  case DG14
  case DG15
  case DG16
  case SOD
  case Unknown
  public func getName() -> Swift.String
  public static func getIDFromName(name: Swift.String) -> TrustID.DataGroupId
  public init?(rawValue: Swift.Int)
  @available(iOS 13, macOS 10.15, *)
  public typealias AllCases = [TrustID.DataGroupId]
  @available(iOS 13, macOS 10.15, *)
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [TrustID.DataGroupId] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public enum LayerType : Swift.Int, Swift.Codable {
  case precomp
  case solid
  case image
  case null
  case shape
  case text
  case unknown
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum MatteType : Swift.Int, Swift.Codable {
  case none
  case add
  case invert
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum BlendMode : Swift.Int, Swift.Codable {
  case normal
  case multiply
  case screen
  case overlay
  case darken
  case lighten
  case colorDodge
  case colorBurn
  case hardLight
  case softLight
  case difference
  case exclusion
  case hue
  case saturation
  case color
  case luminosity
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class DotLottieFile {
  public struct Animation {
    public let animation: TrustID.LottieAnimation
    public let configuration: TrustID.DotLottieConfiguration
  }
  final public var animations: [TrustID.DotLottieFile.Animation] {
    get
  }
  @objc deinit
}
extension TrustID.DotLottieFile : @unchecked Swift.Sendable {
}
public protocol AnimationFontProvider {
  func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
}
final public class DefaultFontProvider : TrustID.AnimationFontProvider {
  public init()
  final public func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
  @objc deinit
}
extension TrustID.DefaultFontProvider : Swift.Equatable {
  public static func == (_: TrustID.DefaultFontProvider, _: TrustID.DefaultFontProvider) -> Swift.Bool
}
public typealias AFResult<Success> = Swift.Result<Success, TrustID.AFError>
public protocol AnyValueProvider {
  var valueType: any Any.Type { get }
  var typeErasedStorage: TrustID.AnyValueProviderStorage { get }
  func hasUpdate(frame: TrustID.AnimationFrameTime) -> Swift.Bool
}
extension TrustID.AnyValueProvider {
  public func value(frame: TrustID.AnimationFrameTime) -> Any
}
public enum ValueProviderStorage<T> where T : TrustID.AnyInterpolatable {
  case singleValue(T)
  case keyframes([TrustID.Keyframe<T>])
  case closure((TrustID.AnimationFrameTime) -> T)
}
public enum AnyValueProviderStorage {
  case singleValue(Any)
  case keyframes([TrustID.Keyframe<Any>], interpolate: (TrustID.AnimationFrameTime) -> Any)
  case closure((TrustID.AnimationFrameTime) -> Any)
}
@_hasMissingDesignatedInitializers public class Request {
  public enum State {
    case initialized
    case resumed
    case suspended
    case cancelled
    case finished
    public static func == (a: TrustID.Request.State, b: TrustID.Request.State) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let id: Foundation.UUID
  final public let underlyingQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let eventMonitor: (any TrustID.EventMonitor)?
  final public let interceptor: (any TrustID.RequestInterceptor)?
  weak public var delegate: (any TrustID.RequestDelegate)? {
    get
  }
  public var state: TrustID.Request.State {
    get
  }
  public var isInitialized: Swift.Bool {
    get
  }
  public var isResumed: Swift.Bool {
    get
  }
  public var isSuspended: Swift.Bool {
    get
  }
  public var isCancelled: Swift.Bool {
    get
  }
  public var isFinished: Swift.Bool {
    get
  }
  public typealias ProgressHandler = (Foundation.Progress) -> Swift.Void
  final public let uploadProgress: Foundation.Progress
  final public let downloadProgress: Foundation.Progress
  public var redirectHandler: (any TrustID.RedirectHandler)? {
    get
  }
  public var cachedResponseHandler: (any TrustID.CachedResponseHandler)? {
    get
  }
  public var credential: Foundation.URLCredential? {
    get
  }
  public var requests: [Foundation.URLRequest] {
    get
  }
  public var firstRequest: Foundation.URLRequest? {
    get
  }
  public var lastRequest: Foundation.URLRequest? {
    get
  }
  public var request: Foundation.URLRequest? {
    get
  }
  public var performedRequests: [Foundation.URLRequest] {
    get
  }
  public var response: Foundation.HTTPURLResponse? {
    get
  }
  public var tasks: [Foundation.URLSessionTask] {
    get
  }
  public var firstTask: Foundation.URLSessionTask? {
    get
  }
  public var lastTask: Foundation.URLSessionTask? {
    get
  }
  public var task: Foundation.URLSessionTask? {
    get
  }
  public var allMetrics: [Foundation.URLSessionTaskMetrics] {
    get
  }
  public var firstMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var lastMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var retryCount: Swift.Int {
    get
  }
  public var error: TrustID.AFError? {
    get
  }
  @discardableResult
  public func cancel() -> Self
  @discardableResult
  public func suspend() -> Self
  @discardableResult
  public func resume() -> Self
  @discardableResult
  public func authenticate(username: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession) -> Self
  @discardableResult
  public func authenticate(with credential: Foundation.URLCredential) -> Self
  @discardableResult
  public func downloadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping TrustID.Request.ProgressHandler) -> Self
  @discardableResult
  public func uploadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping TrustID.Request.ProgressHandler) -> Self
  @discardableResult
  public func redirect(using handler: any TrustID.RedirectHandler) -> Self
  @discardableResult
  public func cacheResponse(using handler: any TrustID.CachedResponseHandler) -> Self
  @discardableResult
  public func cURLDescription(on queue: Dispatch.DispatchQueue, calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func cURLDescription(calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func onURLRequestCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLRequest) -> Swift.Void) -> Self
  @discardableResult
  public func onURLSessionTaskCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLSessionTask) -> Swift.Void) -> Self
  @objc deinit
}
extension TrustID.Request {
  public enum ResponseDisposition {
    case allow
    case cancel
    public static func == (a: TrustID.Request.ResponseDisposition, b: TrustID.Request.ResponseDisposition) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension TrustID.Request : Swift.Equatable {
  public static func == (lhs: TrustID.Request, rhs: TrustID.Request) -> Swift.Bool
}
extension TrustID.Request : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension TrustID.Request : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension TrustID.Request {
  public func cURLDescription() -> Swift.String
}
public protocol RequestDelegate : AnyObject {
  var sessionConfiguration: Foundation.URLSessionConfiguration { get }
  var startImmediately: Swift.Bool { get }
  func cleanup(after request: TrustID.Request)
  func retryResult(for request: TrustID.Request, dueTo error: TrustID.AFError, completion: @escaping (TrustID.RetryResult) -> Swift.Void)
  func retryRequest(_ request: TrustID.Request, withDelay timeDelay: Foundation.TimeInterval?)
}
@_hasMissingDesignatedInitializers public class DataRequest : TrustID.Request {
  final public let convertible: any TrustID.URLRequestConvertible
  public var data: Foundation.Data? {
    get
  }
  @discardableResult
  public func validate(_ validation: @escaping TrustID.DataRequest.Validation) -> Self
  @discardableResult
  @_disfavoredOverload public func onHTTPResponse(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (_ response: Foundation.HTTPURLResponse, _ completionHandler: @escaping (TrustID.Request.ResponseDisposition) -> Swift.Void) -> Swift.Void) -> Self
  @discardableResult
  public func onHTTPResponse(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.HTTPURLResponse) -> Swift.Void) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DataStreamRequest : TrustID.Request {
  public typealias Handler<Success, Failure> = (TrustID.DataStreamRequest.Stream<Success, Failure>) throws -> Swift.Void where Failure : Swift.Error
  public struct Stream<Success, Failure> where Failure : Swift.Error {
    public let event: TrustID.DataStreamRequest.Event<Success, Failure>
    public let token: TrustID.DataStreamRequest.CancellationToken
    public func cancel()
  }
  public enum Event<Success, Failure> where Failure : Swift.Error {
    case stream(Swift.Result<Success, Failure>)
    case complete(TrustID.DataStreamRequest.Completion)
  }
  public struct Completion {
    public let request: Foundation.URLRequest?
    public let response: Foundation.HTTPURLResponse?
    public let metrics: Foundation.URLSessionTaskMetrics?
    public let error: TrustID.AFError?
  }
  public struct CancellationToken {
    public func cancel()
  }
  final public let convertible: any TrustID.URLRequestConvertible
  final public let automaticallyCancelOnStreamError: Swift.Bool
  @discardableResult
  final public func validate(_ validation: @escaping TrustID.DataStreamRequest.Validation) -> Self
  final public func asInputStream(bufferSize: Swift.Int = 1024) -> Foundation.InputStream?
  @discardableResult
  @_disfavoredOverload final public func onHTTPResponse(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (_ response: Foundation.HTTPURLResponse, _ completionHandler: @escaping (TrustID.Request.ResponseDisposition) -> Swift.Void) -> Swift.Void) -> Self
  @discardableResult
  final public func onHTTPResponse(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.HTTPURLResponse) -> Swift.Void) -> Self
  @objc deinit
}
extension TrustID.DataStreamRequest.Stream {
  public var result: Swift.Result<Success, Failure>? {
    get
  }
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public var completion: TrustID.DataStreamRequest.Completion? {
    get
  }
}
@_hasMissingDesignatedInitializers public class DownloadRequest : TrustID.Request {
  public struct Options : Swift.OptionSet {
    public static let createIntermediateDirectories: TrustID.DownloadRequest.Options
    public static let removePreviousFile: TrustID.DownloadRequest.Options
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias ArrayLiteralElement = TrustID.DownloadRequest.Options
    public typealias Element = TrustID.DownloadRequest.Options
    public typealias RawValue = Swift.Int
  }
  public typealias Destination = (_ temporaryURL: Foundation.URL, _ response: Foundation.HTTPURLResponse) -> (destinationURL: Foundation.URL, options: TrustID.DownloadRequest.Options)
  public class func suggestedDownloadDestination(for directory: Foundation.FileManager.SearchPathDirectory = .documentDirectory, in domain: Foundation.FileManager.SearchPathDomainMask = .userDomainMask, options: TrustID.DownloadRequest.Options = []) -> TrustID.DownloadRequest.Destination
  public enum Downloadable {
    case request(any TrustID.URLRequestConvertible)
    case resumeData(Foundation.Data)
  }
  public var resumeData: Foundation.Data? {
    get
  }
  public var fileURL: Foundation.URL? {
    get
  }
  final public let downloadable: TrustID.DownloadRequest.Downloadable
  public func task(forResumeData data: Foundation.Data, using session: Foundation.URLSession) -> Foundation.URLSessionTask
  @discardableResult
  override public func cancel() -> Self
  @discardableResult
  public func cancel(producingResumeData shouldProduceResumeData: Swift.Bool) -> Self
  @discardableResult
  public func cancel(byProducingResumeData completionHandler: @escaping (_ data: Foundation.Data?) -> Swift.Void) -> Self
  @discardableResult
  public func validate(_ validation: @escaping TrustID.DownloadRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers public class UploadRequest : TrustID.DataRequest {
  public enum Uploadable {
    case data(Foundation.Data)
    case file(Foundation.URL, shouldRemove: Swift.Bool)
    case stream(Foundation.InputStream)
  }
  final public let upload: any TrustID.UploadableConvertible
  final public let fileManager: Foundation.FileManager
  public var uploadable: TrustID.UploadRequest.Uploadable?
  public func cleanup()
  @objc deinit
}
public protocol UploadableConvertible {
  func createUploadable() throws -> TrustID.UploadRequest.Uploadable
}
extension TrustID.UploadRequest.Uploadable : TrustID.UploadableConvertible {
  public func createUploadable() throws -> TrustID.UploadRequest.Uploadable
}
public protocol UploadConvertible : TrustID.URLRequestConvertible, TrustID.UploadableConvertible {
}
public struct LottieVector1D : Swift.Hashable, Swift.Sendable {
  public init(_ value: Swift.Double)
  public let value: Swift.Double
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TrustID.LottieVector1D, b: TrustID.LottieVector1D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct LottieVector3D : Swift.Hashable, Swift.Sendable {
  public let x: Swift.Double
  public let y: Swift.Double
  public let z: Swift.Double
  public init(x: Swift.Double, y: Swift.Double, z: Swift.Double)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TrustID.LottieVector3D, b: TrustID.LottieVector3D) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
final public class ColorValueProvider {
  public init(block: @escaping TrustID.ColorValueProvider.ColorValueBlock)
  public init(_ color: TrustID.LottieColor)
  public init(_ keyframes: [TrustID.Keyframe<TrustID.LottieColor>])
  public typealias ColorValueBlock = (CoreFoundation.CGFloat) -> TrustID.LottieColor
  final public var color: TrustID.LottieColor {
    get
    set
  }
  final public var valueType: any Any.Type {
    get
  }
  final public var storage: TrustID.ValueProviderStorage<TrustID.LottieColor> {
    get
  }
  final public func hasUpdate(frame _: CoreFoundation.CGFloat) -> Swift.Bool
  @objc deinit
}
extension TrustID.ColorValueProvider : Swift.Equatable {
  public static func == (lhs: TrustID.ColorValueProvider, rhs: TrustID.ColorValueProvider) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor @preconcurrency open class LottieAnimationViewBase : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func didMoveToWindow()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor @preconcurrency @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc open class SessionDelegate : ObjectiveC.NSObject {
  public init(fileManager: Foundation.FileManager = .default)
  @objc deinit
}
extension TrustID.SessionDelegate : Foundation.URLSessionDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
}
extension TrustID.SessionDelegate : Foundation.URLSessionTaskDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, needNewBodyStream completionHandler: @escaping (Foundation.InputStream?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
}
extension TrustID.SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension TrustID.SessionDelegate : Foundation.URLSessionDownloadDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
}
public enum PACEMappingType {
  case GM
  case IM
  case CAM
  public static func == (a: TrustID.PACEMappingType, b: TrustID.PACEMappingType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class PACEInfo : TrustID.SecurityInfo {
  public static let PARAM_ID_GFP_1024_160: Swift.Int
  public static let PARAM_ID_GFP_2048_224: Swift.Int
  public static let PARAM_ID_GFP_2048_256: Swift.Int
  public static let PARAM_ID_ECP_NIST_P192_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P192_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P224_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P224_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P256_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P256_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P320_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P384_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P384_R1: Swift.Int
  public static let PARAM_ID_ECP_BRAINPOOL_P512_R1: Swift.Int
  public static let PARAM_ID_ECP_NIST_P521_R1: Swift.Int
  override public func getObjectIdentifier() -> Swift.String
  override public func getProtocolOIDString() -> Swift.String
  public func getVersion() -> Swift.Int
  public func getParameterId() -> Swift.Int?
  public func getParameterSpec() throws -> Swift.Int32
  public func getMappingType() throws -> TrustID.PACEMappingType
  public func getKeyAgreementAlgorithm() throws -> Swift.String
  public func getCipherAlgorithm() throws -> Swift.String
  public func getDigestAlgorithm() throws -> Swift.String
  public func getKeyLength() throws -> Swift.Int
  public func createMappingKey() throws -> Swift.OpaquePointer
  public static func getParameterSpec(stdDomainParam: Swift.Int) throws -> Swift.Int32
  public static func toMappingType(oid: Swift.String) throws -> TrustID.PACEMappingType
  public static func toKeyAgreementAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toCipherAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toDigestAlgorithm(oid: Swift.String) throws -> Swift.String
  public static func toKeyLength(oid: Swift.String) throws -> Swift.Int
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Asset : Swift.Codable {
  required public init(from decoder: any Swift.Decoder) throws
  final public let id: Swift.String
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
extension TrustID.Asset : @unchecked Swift.Sendable {
}
public enum SecureMessagingSupportedAlgorithms {
  case DES
  case AES
  public static func == (a: TrustID.SecureMessagingSupportedAlgorithms, b: TrustID.SecureMessagingSupportedAlgorithms) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 13, *)
public class SecureMessaging {
  public init(encryptionAlgorithm: TrustID.SecureMessagingSupportedAlgorithms = .DES, ksenc: [Swift.UInt8], ksmac: [Swift.UInt8], ssc: [Swift.UInt8])
  @objc deinit
}
public enum LottiePlaybackMode : Swift.Hashable {
  case paused(at: TrustID.LottiePlaybackMode.PausedState)
  case playing(_: TrustID.LottiePlaybackMode.PlaybackMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case progress(_: TrustID.AnimationProgressTime)
  @available(*, deprecated, renamed: "LottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case frame(_: TrustID.AnimationFrameTime)
  @available(*, deprecated, renamed: "LottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case time(_: Foundation.TimeInterval)
  @available(*, deprecated, renamed: "LottiePlaybackMode.paused(at:)", message: "Will be removed in a future major release.")
  case pause
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case fromProgress(_: TrustID.AnimationProgressTime?, toProgress: TrustID.AnimationProgressTime, loopMode: TrustID.LottieLoopMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case fromFrame(_: TrustID.AnimationFrameTime?, toFrame: TrustID.AnimationFrameTime, loopMode: TrustID.LottieLoopMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case fromMarker(_: Swift.String?, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: TrustID.LottieLoopMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case marker(_: Swift.String, loopMode: TrustID.LottieLoopMode)
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  case markers(_: [Swift.String])
  public enum PausedState : Swift.Hashable {
    case currentFrame
    case progress(_: TrustID.AnimationProgressTime)
    case frame(_: TrustID.AnimationFrameTime)
    case time(_: Foundation.TimeInterval)
    case marker(_: Swift.String, position: TrustID.LottieMarkerPosition = .start)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TrustID.LottiePlaybackMode.PausedState, b: TrustID.LottiePlaybackMode.PausedState) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum PlaybackMode : Swift.Hashable {
    case fromProgress(_: TrustID.AnimationProgressTime?, toProgress: TrustID.AnimationProgressTime, loopMode: TrustID.LottieLoopMode)
    case fromFrame(_: TrustID.AnimationFrameTime?, toFrame: TrustID.AnimationFrameTime, loopMode: TrustID.LottieLoopMode)
    case fromMarker(_: Swift.String?, toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: TrustID.LottieLoopMode)
    case marker(_: Swift.String, loopMode: TrustID.LottieLoopMode)
    case markers(_: [Swift.String])
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TrustID.LottiePlaybackMode.PlaybackMode, b: TrustID.LottiePlaybackMode.PlaybackMode) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TrustID.LottiePlaybackMode, b: TrustID.LottiePlaybackMode) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension TrustID.LottiePlaybackMode {
  public static var paused: TrustID.LottiePlaybackMode {
    get
  }
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  public static func toProgress(_ toProgress: TrustID.AnimationProgressTime, loopMode: TrustID.LottieLoopMode) -> TrustID.LottiePlaybackMode
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  public static func toFrame(_ toFrame: TrustID.AnimationFrameTime, loopMode: TrustID.LottieLoopMode) -> TrustID.LottiePlaybackMode
  @available(*, deprecated, renamed: "LottiePlaybackMode.playing(_:)", message: "Will be removed in a future major release.")
  public static func toMarker(_ toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: TrustID.LottieLoopMode) -> TrustID.LottiePlaybackMode
}
extension TrustID.LottiePlaybackMode.PlaybackMode {
  public static func toProgress(_ toProgress: TrustID.AnimationProgressTime, loopMode: TrustID.LottieLoopMode) -> TrustID.LottiePlaybackMode.PlaybackMode
  public static func toFrame(_ toFrame: TrustID.AnimationFrameTime, loopMode: TrustID.LottieLoopMode) -> TrustID.LottiePlaybackMode.PlaybackMode
  public static func toMarker(_ toMarker: Swift.String, playEndMarkerFrame: Swift.Bool = true, loopMode: TrustID.LottieLoopMode) -> TrustID.LottiePlaybackMode.PlaybackMode
}
public enum LottieMarkerPosition : Swift.Hashable {
  case start
  case end
  public static func == (a: TrustID.LottieMarkerPosition, b: TrustID.LottieMarkerPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class BundleImageProvider : TrustID.AnimationImageProvider {
  public init(bundle: Foundation.Bundle, searchPath: Swift.String?, contentsGravity: QuartzCore.CALayerContentsGravity = .resize)
  public func imageForAsset(asset: TrustID.ImageAsset) -> CoreGraphics.CGImage?
  public func contentsGravity(for _: TrustID.ImageAsset) -> QuartzCore.CALayerContentsGravity
  @objc deinit
}
extension TrustID.BundleImageProvider : Swift.Equatable {
  public static func == (lhs: TrustID.BundleImageProvider, rhs: TrustID.BundleImageProvider) -> Swift.Bool
}
@available(iOS 13, *)
public class PACEHandler {
  public init(cardAccess: TrustID.CardAccess, tagReader: TrustID.TagReader) throws
  public func doPACE(mrzKey: Swift.String, completed: @escaping (Swift.Bool) -> ())
  @objc deinit
}
public protocol AnimationKeypathTextProvider : AnyObject {
  func text(for keypath: TrustID.AnimationKeypath, sourceText: Swift.String) -> Swift.String?
}
@available(*, deprecated, message: "`AnimationKeypathTextProvider` has been deprecated and renamed to `LegacyAnimationTextProvider`. Instead, conform to `AnimationKeypathTextProvider` instead or conform to `LegacyAnimationTextProvider` explicitly.")
public typealias AnimationTextProvider = TrustID.LegacyAnimationTextProvider
public protocol LegacyAnimationTextProvider : TrustID.AnimationKeypathTextProvider {
  func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
}
extension TrustID.LegacyAnimationTextProvider {
  public func text(for _: TrustID.AnimationKeypath, sourceText _: Swift.String) -> Swift.String?
}
final public class DictionaryTextProvider : TrustID.AnimationKeypathTextProvider, TrustID.LegacyAnimationTextProvider {
  public init(_ values: [Swift.String : Swift.String])
  final public func text(for keypath: TrustID.AnimationKeypath, sourceText: Swift.String) -> Swift.String?
  final public func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
extension TrustID.DictionaryTextProvider : Swift.Equatable {
  public static func == (lhs: TrustID.DictionaryTextProvider, rhs: TrustID.DictionaryTextProvider) -> Swift.Bool
}
final public class DefaultTextProvider : TrustID.AnimationKeypathTextProvider, TrustID.LegacyAnimationTextProvider {
  public init()
  final public func textFor(keypathName _: Swift.String, sourceText: Swift.String) -> Swift.String
  final public func text(for _: TrustID.AnimationKeypath, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
extension TrustID.DefaultTextProvider : Swift.Equatable {
  public static func == (_: TrustID.DefaultTextProvider, _: TrustID.DefaultTextProvider) -> Swift.Bool
}
public struct RequestAdapterState {
  public let requestID: Foundation.UUID
  public let session: TrustID.Session
}
public protocol RequestAdapter {
  func adapt(_ urlRequest: Foundation.URLRequest, for session: TrustID.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  func adapt(_ urlRequest: Foundation.URLRequest, using state: TrustID.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
}
extension TrustID.RequestAdapter {
  public func adapt(_ urlRequest: Foundation.URLRequest, using state: TrustID.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
}
public enum RetryResult {
  case retry
  case retryWithDelay(Foundation.TimeInterval)
  case doNotRetry
  case doNotRetryWithError(any Swift.Error)
}
public protocol RequestRetrier {
  func retry(_ request: TrustID.Request, for session: TrustID.Session, dueTo error: any Swift.Error, completion: @escaping (TrustID.RetryResult) -> Swift.Void)
}
public protocol RequestInterceptor : TrustID.RequestAdapter, TrustID.RequestRetrier {
}
extension TrustID.RequestInterceptor {
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: TrustID.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  public func retry(_ request: TrustID.Request, for session: TrustID.Session, dueTo error: any Swift.Error, completion: @escaping (TrustID.RetryResult) -> Swift.Void)
}
public typealias AdaptHandler = (Foundation.URLRequest, TrustID.Session, _ completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void) -> Swift.Void
public typealias RetryHandler = (TrustID.Request, TrustID.Session, any Swift.Error, _ completion: @escaping (TrustID.RetryResult) -> Swift.Void) -> Swift.Void
open class Adapter : TrustID.RequestInterceptor {
  public init(_ adaptHandler: @escaping TrustID.AdaptHandler)
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: TrustID.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  open func adapt(_ urlRequest: Foundation.URLRequest, using state: TrustID.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension TrustID.RequestAdapter where Self == TrustID.Adapter {
  public static func adapter(using closure: @escaping TrustID.AdaptHandler) -> TrustID.Adapter
}
open class Retrier : TrustID.RequestInterceptor {
  public init(_ retryHandler: @escaping TrustID.RetryHandler)
  open func retry(_ request: TrustID.Request, for session: TrustID.Session, dueTo error: any Swift.Error, completion: @escaping (TrustID.RetryResult) -> Swift.Void)
  @objc deinit
}
extension TrustID.RequestRetrier where Self == TrustID.Retrier {
  public static func retrier(using closure: @escaping TrustID.RetryHandler) -> TrustID.Retrier
}
open class Interceptor : TrustID.RequestInterceptor {
  final public let adapters: [any TrustID.RequestAdapter]
  final public let retriers: [any TrustID.RequestRetrier]
  public init(adaptHandler: @escaping TrustID.AdaptHandler, retryHandler: @escaping TrustID.RetryHandler)
  public init(adapter: any TrustID.RequestAdapter, retrier: any TrustID.RequestRetrier)
  public init(adapters: [any TrustID.RequestAdapter] = [], retriers: [any TrustID.RequestRetrier] = [], interceptors: [any TrustID.RequestInterceptor] = [])
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: TrustID.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  open func adapt(_ urlRequest: Foundation.URLRequest, using state: TrustID.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  open func retry(_ request: TrustID.Request, for session: TrustID.Session, dueTo error: any Swift.Error, completion: @escaping (TrustID.RetryResult) -> Swift.Void)
  @objc deinit
}
extension TrustID.RequestInterceptor where Self == TrustID.Interceptor {
  public static func interceptor(adapter: @escaping TrustID.AdaptHandler, retrier: @escaping TrustID.RetryHandler) -> TrustID.Interceptor
  public static func interceptor(adapter: any TrustID.RequestAdapter, retrier: any TrustID.RequestRetrier) -> TrustID.Interceptor
  public static func interceptor(adapters: [any TrustID.RequestAdapter] = [], retriers: [any TrustID.RequestRetrier] = [], interceptors: [any TrustID.RequestInterceptor] = []) -> TrustID.Interceptor
}
public typealias AFDataResponse<Success> = TrustID.DataResponse<Success, TrustID.AFError>
public typealias AFDownloadResponse<Success> = TrustID.DownloadResponse<Success, TrustID.AFError>
public struct DataResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension TrustID.DataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension TrustID.DataResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> TrustID.DataResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> TrustID.DataResponse<NewSuccess, any Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> TrustID.DataResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> TrustID.DataResponse<Success, any Swift.Error> where NewFailure : Swift.Error
}
public struct DownloadResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let fileURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, resumeData: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension TrustID.DownloadResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension TrustID.DownloadResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> TrustID.DownloadResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> TrustID.DownloadResponse<NewSuccess, any Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> TrustID.DownloadResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> TrustID.DownloadResponse<Success, any Swift.Error> where NewFailure : Swift.Error
}
@available(iOS 13, *)
public struct ResponseAPDU {
  public var data: [Swift.UInt8]
  public var sw1: Swift.UInt8
  public var sw2: Swift.UInt8
  public init(data: [Swift.UInt8], sw1: Swift.UInt8, sw2: Swift.UInt8)
}
@objc public protocol TrustIdClientDelegate {
  @objc func onCompletion(action: TrustID.TrustIdAction)
}
@objc public enum TrustIdDocumentType : Swift.Int {
  case IdCard = 0
  case Passport
  case Manual
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc final public class CompatibleAnimation : ObjectiveC.NSObject {
  @objc public init(name: Swift.String, subdirectory: Swift.String? = nil, bundle: Foundation.Bundle = Bundle.main)
  @objc deinit
}
@objc public enum CompatibleRenderingEngineOption : Swift.Int {
  case shared
  case defaultEngine
  case automatic
  case mainThread
  case coreAnimation
  public static func generateLottieConfiguration(_ configuration: TrustID.CompatibleRenderingEngineOption) -> TrustID.LottieConfiguration
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum CompatibleBackgroundBehavior : Swift.Int {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  case continuePlaying
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor @preconcurrency final public class CompatibleAnimationView : UIKit.UIView {
  @objc @_Concurrency.MainActor @preconcurrency convenience public init(compatibleAnimation: TrustID.CompatibleAnimation)
  @objc @_Concurrency.MainActor @preconcurrency public init(compatibleAnimation: TrustID.CompatibleAnimation, compatibleRenderingEngineOption: TrustID.CompatibleRenderingEngineOption)
  @objc @_Concurrency.MainActor @preconcurrency convenience public init(url: Foundation.URL)
  @objc @_Concurrency.MainActor @preconcurrency public init(url: Foundation.URL, compatibleRenderingEngineOption: TrustID.CompatibleRenderingEngineOption)
  @objc @_Concurrency.MainActor @preconcurrency convenience public init(data: Foundation.Data)
  @objc @_Concurrency.MainActor @preconcurrency public init(data: Foundation.Data, compatibleRenderingEngineOption: TrustID.CompatibleRenderingEngineOption)
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @objc @_Concurrency.MainActor @preconcurrency final public var compatibleAnimation: TrustID.CompatibleAnimation? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var loopAnimationCount: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var compatibleDictionaryTextProvider: TrustID.CompatibleDictionaryTextProvider? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor @preconcurrency @objc override final public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var shouldRasterizeWhenIdle: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentProgress: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var duration: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentTime: Foundation.TimeInterval {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var currentFrame: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationFrame: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var realtimeAnimationProgress: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var animationSpeed: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var respectAnimationFrameRate: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var isAnimationPlaying: Swift.Bool {
    @objc get
  }
  @objc @_Concurrency.MainActor @preconcurrency final public var backgroundMode: TrustID.CompatibleBackgroundBehavior {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor @preconcurrency final public func play()
  @objc @_Concurrency.MainActor @preconcurrency final public func play(completion: ((Swift.Bool) -> Swift.Void)?)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromProgress: CoreFoundation.CGFloat, toProgress: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromFrame: CoreFoundation.CGFloat, toFrame: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(fromMarker: Swift.String, toMarker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func play(marker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor @preconcurrency final public func stop()
  @objc @_Concurrency.MainActor @preconcurrency final public func pause()
  @objc @_Concurrency.MainActor @preconcurrency final public func reloadImages()
  @objc @_Concurrency.MainActor @preconcurrency final public func forceDisplayUpdate()
  @objc @_Concurrency.MainActor @preconcurrency final public func getValue(for keypath: TrustID.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> Any?
  @objc @_Concurrency.MainActor @preconcurrency final public func logHierarchyKeypaths()
  @objc @_Concurrency.MainActor @preconcurrency final public func setColorValue(_ color: UIKit.UIColor, forKeypath keypath: TrustID.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor @preconcurrency final public func getColorValue(for keypath: TrustID.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> UIKit.UIColor?
  @objc @_Concurrency.MainActor @preconcurrency final public func addSubview(_ subview: TrustID.AnimationSubview, forLayerAt keypath: TrustID.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor @preconcurrency final public func convert(rect: CoreFoundation.CGRect, toLayerAt keypath: TrustID.CompatibleAnimationKeypath?) -> CoreFoundation.CGRect
  @objc @_Concurrency.MainActor @preconcurrency final public func convert(point: CoreFoundation.CGPoint, toLayerAt keypath: TrustID.CompatibleAnimationKeypath?) -> CoreFoundation.CGPoint
  @objc @_Concurrency.MainActor @preconcurrency final public func progressTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency final public func frameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor @preconcurrency final public func durationFrameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc deinit
}
@objc final public class CompatibleDictionaryTextProvider : ObjectiveC.NSObject {
  @objc public init(values: [Swift.String : Swift.String])
  @objc deinit
}
public typealias AnimationFrameTime = CoreFoundation.CGFloat
public typealias AnimationProgressTime = CoreFoundation.CGFloat
public enum ColorFormatDenominator : Swift.Hashable {
  case One
  case OneHundred
  case TwoFiftyFive
  public static func == (a: TrustID.ColorFormatDenominator, b: TrustID.ColorFormatDenominator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct LottieColor : Swift.Hashable {
  public var r: Swift.Double
  public var g: Swift.Double
  public var b: Swift.Double
  public var a: Swift.Double
  public init(r: Swift.Double, g: Swift.Double, b: Swift.Double, a: Swift.Double, denominator: TrustID.ColorFormatDenominator = .One)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TrustID.LottieColor, b: TrustID.LottieColor) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 13, macOS 10.15, *)
public class OpenSSLUtils {
  public static func getOpenSSLError() -> Swift.String
  @available(iOS 13, macOS 10.15, *)
  public static func getPublicKeyData(from key: Swift.OpaquePointer) -> [Swift.UInt8]?
  @available(iOS 13, macOS 10.15, *)
  public static func decodePublicKeyFromBytes(pubKeyData: [Swift.UInt8], params: Swift.OpaquePointer) -> Swift.OpaquePointer?
  public static func computeSharedSecret(privateKeyPair: Swift.OpaquePointer, publicKey: Swift.OpaquePointer) -> [Swift.UInt8]
  @objc deinit
}
extension TrustID.DotLottieFile {
  public enum SynchronouslyBlockingCurrentThread {
    public static func loadedFrom(filepath: Swift.String, dotLottieCache: (any TrustID.DotLottieCacheProvider)? = DotLottieCache.sharedCache) -> Swift.Result<TrustID.DotLottieFile, any Swift.Error>
    public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, dotLottieCache: (any TrustID.DotLottieCacheProvider)? = DotLottieCache.sharedCache) -> Swift.Result<TrustID.DotLottieFile, any Swift.Error>
    public static func loadedFrom(data: Foundation.Data, filename: Swift.String) -> Swift.Result<TrustID.DotLottieFile, any Swift.Error>
  }
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, dotLottieCache: (any TrustID.DotLottieCacheProvider)? = DotLottieCache.sharedCache) async throws -> TrustID.DotLottieFile
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, dotLottieCache: (any TrustID.DotLottieCacheProvider)? = DotLottieCache.sharedCache, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<TrustID.DotLottieFile, any Swift.Error>) -> Swift.Void)
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  public static func loadedFrom(filepath: Swift.String, dotLottieCache: (any TrustID.DotLottieCacheProvider)? = DotLottieCache.sharedCache) async throws -> TrustID.DotLottieFile
  public static func loadedFrom(filepath: Swift.String, dotLottieCache: (any TrustID.DotLottieCacheProvider)? = DotLottieCache.sharedCache, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<TrustID.DotLottieFile, any Swift.Error>) -> Swift.Void)
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  public static func asset(named name: Swift.String, bundle: Foundation.Bundle = Bundle.main, dotLottieCache: (any TrustID.DotLottieCacheProvider)? = DotLottieCache.sharedCache) async throws -> TrustID.DotLottieFile
  public static func asset(named name: Swift.String, bundle: Foundation.Bundle = Bundle.main, dotLottieCache: (any TrustID.DotLottieCacheProvider)? = DotLottieCache.sharedCache, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<TrustID.DotLottieFile, any Swift.Error>) -> Swift.Void)
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, dotLottieCache: (any TrustID.DotLottieCacheProvider)? = DotLottieCache.sharedCache) async throws -> TrustID.DotLottieFile
  public static func loadedFrom(url: Foundation.URL, session: Foundation.URLSession = .shared, dotLottieCache: (any TrustID.DotLottieCacheProvider)? = DotLottieCache.sharedCache, handleResult: @escaping (Swift.Result<TrustID.DotLottieFile, any Swift.Error>) -> Swift.Void)
  public static func loadedFrom(data: Foundation.Data, filename: Swift.String, dispatchQueue: Dispatch.DispatchQueue = .dotLottie, handleResult: @escaping (Swift.Result<TrustID.DotLottieFile, any Swift.Error>) -> Swift.Void)
  @available(iOS 13.0, macOS 10.15, tvOS 13.0, *)
  public static func loadedFrom(data: Foundation.Data, filename: Swift.String, dispatchQueue: Dispatch.DispatchQueue = .dotLottie) async throws -> TrustID.DotLottieFile
}
extension Dispatch.DispatchQueue {
  public static let dotLottie: Dispatch.DispatchQueue
}
extension TrustID.LogLevel : Swift.Equatable {}
extension TrustID.LogLevel : Swift.Hashable {}
extension TrustID.LogLevel : Swift.RawRepresentable {}
extension TrustID.TrustIdLocale : Swift.Equatable {}
extension TrustID.TrustIdLocale : Swift.Hashable {}
extension TrustID.TrustIdLocale : Swift.RawRepresentable {}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
extension TrustID.LottieButton : SwiftUICore.View {}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
extension TrustID.LottieButton : Swift.Sendable {}
extension TrustID.AuthenticationError : Swift.Equatable {}
extension TrustID.AuthenticationError : Swift.Hashable {}
extension TrustID.CoordinateSpace : Swift.Equatable {}
extension TrustID.CoordinateSpace : Swift.Hashable {}
extension TrustID.CoordinateSpace : Swift.RawRepresentable {}
extension TrustID.PassportAuthenticationStatus : Swift.Equatable {}
extension TrustID.PassportAuthenticationStatus : Swift.Hashable {}
extension TrustID.FloatValueProvider : TrustID.AnyValueProvider {}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension TrustID.DeflateRequestCompressor.DuplicateHeaderBehavior : Swift.Equatable {}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension TrustID.DeflateRequestCompressor.DuplicateHeaderBehavior : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension TrustID.CertificateType : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension TrustID.CertificateType : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension TrustID.CertificateItem : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension TrustID.CertificateItem : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension TrustID.CertificateItem : Swift.RawRepresentable {}
extension TrustID.PointValueProvider : TrustID.AnyValueProvider {}
@available(iOS 13, macOS 10.15, *)
extension TrustID.DocTypeEnum : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension TrustID.DocTypeEnum : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension TrustID.DocTypeEnum : Swift.RawRepresentable {}
extension TrustID.URLEncoding.Destination : Swift.Equatable {}
extension TrustID.URLEncoding.Destination : Swift.Hashable {}
extension TrustID.URLEncoding.BoolEncoding : Swift.Equatable {}
extension TrustID.URLEncoding.BoolEncoding : Swift.Hashable {}
extension TrustID.JSONEncoding.Error : Swift.Equatable {}
extension TrustID.JSONEncoding.Error : Swift.Hashable {}
extension TrustID.URLEncodedFormParameterEncoder.Destination : Swift.Equatable {}
extension TrustID.URLEncodedFormParameterEncoder.Destination : Swift.Hashable {}
extension TrustID.BlendMode : Swift.Equatable {}
extension TrustID.BlendMode : Swift.Hashable {}
extension TrustID.BlendMode : Swift.RawRepresentable {}
extension TrustID.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Equatable {}
extension TrustID.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Hashable {}
extension TrustID.URLEncodedFormEncoder.BoolEncoding : Swift.Equatable {}
extension TrustID.URLEncodedFormEncoder.BoolEncoding : Swift.Hashable {}
extension TrustID.URLEncodedFormEncoder.SpaceEncoding : Swift.Equatable {}
extension TrustID.URLEncodedFormEncoder.SpaceEncoding : Swift.Hashable {}
extension TrustID.LottieBackgroundBehavior : Swift.Equatable {}
extension TrustID.LottieBackgroundBehavior : Swift.Hashable {}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
extension TrustID.LottieView : SwiftUICore.View {}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
extension TrustID.LottieView : Swift.Sendable {}
extension TrustID.SizeValueProvider : TrustID.AnyValueProvider {}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
extension TrustID.LottieSwitch : SwiftUICore.View {}
@available(iOS 13.0, tvOS 13.0, macOS 10.15, *)
extension TrustID.LottieSwitch : Swift.Sendable {}
extension TrustID.GradientValueProvider : TrustID.AnyValueProvider {}
extension TrustID.TrustIdPresentationStyle : Swift.Equatable {}
extension TrustID.TrustIdPresentationStyle : Swift.Hashable {}
extension TrustID.TrustIdPresentationStyle : Swift.RawRepresentable {}
extension TrustID.AnimatedSwitch.CancelBehavior : Swift.Equatable {}
extension TrustID.AnimatedSwitch.CancelBehavior : Swift.Hashable {}
extension TrustID.TrustIdEnvironment : Swift.Equatable {}
extension TrustID.TrustIdEnvironment : Swift.Hashable {}
extension TrustID.TrustIdEnvironment : Swift.RawRepresentable {}
@available(iOS 13, macOS 10.15, *)
extension TrustID.DataGroupId : Swift.Equatable {}
@available(iOS 13, macOS 10.15, *)
extension TrustID.DataGroupId : Swift.Hashable {}
@available(iOS 13, macOS 10.15, *)
extension TrustID.DataGroupId : Swift.RawRepresentable {}
extension TrustID.LayerType : Swift.Equatable {}
extension TrustID.LayerType : Swift.Hashable {}
extension TrustID.LayerType : Swift.RawRepresentable {}
extension TrustID.MatteType : Swift.Equatable {}
extension TrustID.MatteType : Swift.Hashable {}
extension TrustID.MatteType : Swift.RawRepresentable {}
extension TrustID.Request.State : Swift.Equatable {}
extension TrustID.Request.State : Swift.Hashable {}
extension TrustID.Request.ResponseDisposition : Swift.Equatable {}
extension TrustID.Request.ResponseDisposition : Swift.Hashable {}
extension TrustID.ColorValueProvider : TrustID.AnyValueProvider {}
extension TrustID.PACEMappingType : Swift.Equatable {}
extension TrustID.PACEMappingType : Swift.Hashable {}
extension TrustID.SecureMessagingSupportedAlgorithms : Swift.Equatable {}
extension TrustID.SecureMessagingSupportedAlgorithms : Swift.Hashable {}
extension TrustID.TrustIdDocumentType : Swift.Equatable {}
extension TrustID.TrustIdDocumentType : Swift.Hashable {}
extension TrustID.TrustIdDocumentType : Swift.RawRepresentable {}
extension TrustID.CompatibleRenderingEngineOption : Swift.Equatable {}
extension TrustID.CompatibleRenderingEngineOption : Swift.Hashable {}
extension TrustID.CompatibleRenderingEngineOption : Swift.RawRepresentable {}
extension TrustID.CompatibleBackgroundBehavior : Swift.Equatable {}
extension TrustID.CompatibleBackgroundBehavior : Swift.Hashable {}
extension TrustID.CompatibleBackgroundBehavior : Swift.RawRepresentable {}
